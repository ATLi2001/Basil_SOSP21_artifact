Safe and efficient online data sharing among mutually distrustful
parties offers exciting opportunities for a variety of applications,
including healthcare~\cite{}, financial services~\cite{}, supply chain
management~~\cite{} and more~\cite{}. It is also challenging, as it
requires building a new breed of systems, which can offer to their
users the functionaalities of a distributed database but do so under
much weaker trust assumptions that the database community has
typically considered.

An increasingly popular answer to this challenge are permissioned
blockchains. These systems use a Byzantine fault tolerant (BFT)
replicated state machine protocol\cite{} to produce a totally ordered
log of client transactions, upon which they layer a database
abstraction.  The obvious appeal of this approach is that it can
immediately benefit from, and  build upon, the existing BFT
literature. However, the total order it imposes on transactions is not
only costly to implement and hard to scale, but it is unnecessary for
many of its target applications. For example, unrelated financial
transactions need not be totally ordered, and supply chains, despite
their name, are actually complex networks that generate and process
many logically concurrent transactions.

This mismatch motivates us to explore in this paper a fundamentally
different design point: instead of layering database functionalities on top
of BFT state machine replication, we build \sys, \la{the first (?)} a
{\em Byzantine fault tolerant transactional key-value store}.

In principle, a BFT database can yield several benefits.

First, it can overcome the scalability bottleneck of a low-level
implementation based on a totally ordered BFT log. Sharded blockchains
can mitigate this bottleneck, but only to a point, as the cuncurrency
they can achieve is limited by the degree to which transactions can be
executed on individual shards. In contrast, \sys uses a
client-driven protocol that bypasses the ordering bottleneck and
leverages databases' ability, honed over decades of research in
concurrency control, to support highly concurrent transaction
processing over a sharded database while retaining, to ease reasoning
about correctness, the capacity to generate executions equivalent to a
total order of commmitted transaction.

% an explicit ordering service 

Second, by doing away with an underlying totally ordered log, it can
sidestep the growing concerns~\cite{} about whether blockchains
order transactions fairly. Though the notion of fairness in this
context has not been rigorously defined, leaving the ordering to the
whim of a potentially Byzantine leader, as some protocols do~\cite{}
is intuitively problematic; to limit its discretion, other protocols
rotate the leader's responsibility, thus reducing, but not
eliminating, the skew it can introduce. In contrast, \sys leaves the
responsibility of driving the replication and distributed commit of a
transaction to the client that proposes it, and allows different
shards to order transactions in different orders, as long asways, as
long as serializability can be maintained.

Third, it avoids the duplicate ordering costs of transactional systems
built on top of state machine replication. As Tapir noted~\cite{},
these systems require, for replication, a consistent ordering of
operations within each shard, and additionally enforce, for
distributed commit, a serial order of transactions across
shards~\cite{}. In contrast, \sys{} integrates distributed commit and
replication through an optimistic concurrency control (OCC)~\cite{} protocol, to
limit coordination only to the validation step of the distributed commit
protocol---and does so in in a setting where clients, as well as a
fraction of the replicas in each shard, can behave maliciously.

In practice, reaping these befits requires to address several
technical obstacles. As any client-driven, OCC-based protocol, \sys
is vulnerable to aborts if transactions interleave unfavorably during
validation---but these concerns are compounded in a Byzantine
setting. First, since reading from a single local replica can no
longer guarantee integrity, it becomes necessary to read remotely,
thus increasing the window of time during which unfortunate
interleavings may occur. Even worse,  Byzantine clients and replicas may
collude to actively sabotage the commit chances of transactions issued
by correct clients.


To mitigate the first concern, \sys's OCC protocol uses multi-version
time-stamp ordering (MVTSO) to minmizes abort windows for read
requests.  \la{to be massaged. Also point out that there are
  individual consensus decision instead of tying all consensus
  decision together}.  To address the second, \sys's design is driven
by the ethos of \textit{independent operability}; both safety
\fs{(integrity, serializability)} and liveness \fs{ability to issue
  and complete TX} are per-client properties and independent from one
client to another.

adopts an 


\la{Point to our ethos as the way we try to address the challenges}
\la{briefly introduce the system, unclear in what detail--but not too much}
\la{The describe our experience in building and evaluating: we have implemented... We find...}
\la{Conclude with the key contributions}

