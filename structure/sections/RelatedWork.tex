
%-------------------------------------------------------------------------------
\section{Related Work}  
%-------------------------------------------------------------------------------
\paragraph{Totally ordered ledgers}
\fs{remove citations that are just there for the sake of citations, some paxos versions, some less relevant bft ones}
State machine replication (SMR) \cite{schneider1990implementing} maintains a total order of requests across replicas, both in the crash failure model \fs{paxos versions:} \cite{Li2007, Lampson2001, Lamport98Paxos, Lamport2005a, Lamport2005, Lamport01Paxos, Chandra2007} \fs{other:} \cite{junqueira2011zab, van2014vive, oki1988viewstampeda, liskov2012viewstamped, ongaro2014search}) and in the byzantine setting \cite{castro1999practical, martin2006fast, kotla2007zyzzyva,  gueta2018sbft, clement2009making, buchman2016tendermint, yin2019hotstuff, Clement09Upright, duan2014hbft    , pires2018generalized, bessani2014state, lamport2011byzantizing, arun2019ezbft, malkhi2019flexible, duan2014hbft, yin2003separating, Guerraoui08Next, Kotla04High,  liskov2010viewstamped}. Most recently, BFT protocols have extensively been used as the main building block of blockchain systems \cite{Hyperledger, EthereumQuorum, buchman2016tendermint, al2017chainspace, kokoris2018omniledger,  gilad2017algorand, baudet2019state}. To maintain the total order, these techniques must process  all operations sequentially (for both agreement and execution), which introduces an inherent scalability bottleneck. They are, in addition, primarily leader-based which introduces additional scalability issues \cite{moraru2013there, zhang2015tapir, stathakopoulou2019mir} as well as fairness concerns. 

\paragraph{Enforcing Partial Order}
\fs{shorten this section a lot}
Recent efforts to address the scalability bottleneck reduce unecessary coordination/serialization between commutative operations by inducing only a partial order, and can be broadly classified in three ways:

\textbf{1. Fine-grained ordering}: One class of approaches attempts to only order conflicting operations by leveraging knowledge of transaction semantics (i.e. read/write sets) and optionally speculating on concurrent transaction execution by either re-ordering or aborting when conflicts arise. Existing work \cite{moraru2013there, lamport2005generalized, sutra2011fast, li2012redblue, park2019exploiting, yan2018carousel, mu2016consolidating, mu2014extracting, zhang2015tapir, kraska2013mdcc}, however, targets almost exlusively the crash failure model. To the best of our knowledge, Bilbos \cite{bazzi2018clairvoyant} is the only BFT system that offers SMR for commutative transactions, but unlike \sys is limited to a static transaction model and introduces blocking, as any transaction must wait for all potentially concurrent transactions to complete. Other quorum based systems whose strucutre \sys resembles \cite{malkhi1998byzantine, abd2005fault, cowling2006hq, liskov2006tolerating} allow for commutativity, but do not offer transactions. \fs{Q/U resembles Logging in \sys - but has no liveness on its own.}

\textbf{2. Sharding} In the blockchain space, sharding has been explored as mechanism to parallelize independent transactions across shards, while relying on total-order primitives within \cite{zamani2018rapidchain, al2017chainspace, kokoris2018omniledger}; In \sys we argue however, that inducing a partial order via sharding is merely a limited engineering optimization. Existing work in the crash failure model \cite{zhang2016operation, zhang2015tapir, mu2016consolidating } points out that layering sharding and transactional control on top of replication (cite Spanner?) incurs redundant coordination, and improves performance by integrating both layers. \sys is the first to adopt this rationale in the byzantine fault model.

\textbf{3. DAGs} Lastly, the use of Directed Acyclic Graphs (DAGs) that allow to parallelize agreement instances, has been explored in several permissionless blockchain networks \cite{pervez2018comparative, popov2016tangle, rocket2018snowflake}. It remains unclear whether practical applications exist for the permissioned setting - designing a BFT protocol that replicates a DAG instead of a totally ordered ledger is an interesting avenue for future work.


\paragraph{Byzantine Databases}
In \sys we argue that blockchain functionality, i.e. a distributed transactional system, should be captured by a BFT Database (DB). There exist a series of work offering explicit BFT DBs: HRDB \cite{vandiver2007tolerating} offers interactive transactions for a replicated DB, but relies on a trusted shepherd layer. Byzantium \cite{garcia2011efficient} designs a middleware system that utilizes PBFT as atomic broadcast (AB) and provides Snapshot Isolation via a primary backup validation scheme. In \cite{pedone2012byzantine} Pedone et al. too, rely on AB to design an OCC-architecture similar to \sys. Augustus \cite{padilha2013augustus} and Callinicos \cite{padilha2016callinicos} leverage sharding for scalability in the mini-transaction model \cite{aguilera2007sinfonia} and implementing an optimistic and locking based execution model respectively on top of atomic broadcast.
We expand on existing research to 1) be leaderless and more scalable by allowing un-ordered replication rather than AB, 2) provide interactive read-write transactions, and 3) offer sharding for horizontal scaling.
\subparagraph{Byzantine Clients}
Existing work concerned with byzantine clients addresses mechanisms to reduce frequency and severity of client misbehavior \cite{liskov2006tolerating, garcia2011efficient, pedone2012byzantine, padilha2013augustus, padilha2016callinicos, luiz2011byzantine, }. We reformulate transactional corectness guarantees in a byzantine setting to be more explicit about byzantine client behavior \fs{too vague} and extend Liskov and Rodrigues' \cite{liskov2006tolerating} definition of Byz-Linearizability to transactions (Byz-Serializability). 




