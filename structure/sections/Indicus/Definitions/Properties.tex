\subsubsection{System properties}
We offer Clients an interactive transaction interface that implements ACID transactions. While  Isolation guarantees may be violated by individual byzantine Replicas, Indicus maintains the view of an ACID compliant state to all honest Clients. 

Specifically, we guarantee to Clients that the Database is \textit{byzantine Serializable}. Intuitively this Isolation level guarantees that all honest Clients experience the Database as if there serializable. In order to formally capture this we lay some ground work \cite{bernstein1987concurrency}: \footnote{We modify and expand on definitions for BFT-linearizability from \cite{liskov2006tolerating}}.\\

Let $Op =  \{r, w\} \times K \times V $ and $Dec = \{Commit, \,Abort\}$ be the sets of possible operations and decisions respectively, where $K$ is the set of existing data items (keys) and $V$ the range of possible values. A \textit{request} $req \in (Op \cup Dec) \times C$ maps any such operation or decision to the issuing Client from set $C$. We denote with $Hon \subseteq C$ the subset of honest Clients. 

A transaction $T \coloneqq (REQ, <_T)$ is a set $REQ \coloneqq \{req_1, \dots, req_t \}$ of requests issued by the same client $c$, and a partial order $<_T$ such that a) $REQ$ contains an arbitrary number of operations, and exactly one decision $req_t = (Dec, c) \in REQ$, b) for every read and write operation on a shared key $k$, either $(r, k, v_r) <_T (w, k, v_w)$ or $(w, k, v_w) <_T (r, k, v_r)$ \fs{(but not both) - trivial by asymmetry property of partial order}, and c) for all read and write operations $({r,w} \times k \times v) <_T dec$.
\textbf{History H.} A History represents the interleaving on concurrently executed transactions. Concretely, we define a \textit{history} $H \coloneqq (R, <)$ where $R$ is finite sequence of
requests, such that $R \supseteq \bigcup_i T_i$, and $< \supseteq \bigcup_i <_{T_i}$ .
Let $Committed(H)$ be the subsequence of all Transactions with $req_{t} = Commit$. A History H is legal if every read request $(r, k, v)$ is preceded by a matching write request $(w, k, v)$ and there is no other write $(w, k, v')$ inbetween \fs{could formalize this with order:} $\forall (r, k, v).\exists (w, k v). (w,k,v) < (r,k,v) \land \neg \exists (w, k, v'). v\neq v' \land (w, k,v) < (w,k, v') < (r, k, v)$. For two transactions $T_i$ and $T_j$, we denote $T_i < T_j$ iff $\forall req_i, req_j \in T_i, T_j. req_i < req_j$. A history is serial if all transactions are executed sequentially: $\forall T_i, T_j: T_i < T_j \lor T_j < T_i$.

\textbf{Serializable} 
A history H is serializable if there exists a serial permutation H' of Committed(H) such that H' is legal.

We define a projection $H|_c$ as the subsequence of requests in $H$ that were issued by Client $c$.
We further define:\\
\textbf{Honest History H(P).} Given protocol P, A \textit{history H} is \textit{honest} if it was generated by participants who all follow P, i.e: $H(P) \equiv H = H|_{Hon}$.\\
\textbf{Honest-View Equivalent.} A \textit{history H} is honest-view equivalent to a \textit{history H'} if the Operations and Decisions of all honest Clients are the same and if the final writes are the same.\\
\textbf{Byz-I} Given a protocol $P$ and an isolation level $I$:
A history H is \textit{byzantine-I} if there exists an honest history \textit{H'} such that H is honest-view equivalent to H' and H' satisfies I. \\

This definition captures the requirements for any byzantine tolerant protocol that strives to maintain byzantine Isolation level I.
Informally a byzantine Isolation level states that the state that honest Clients experience must be explicable by an execution in which all participants were honest. Note, that we make no assumptions on the state a byzantine client \textit{chooses} to experience; Byzantine client reads may be arbitrary, i.e. integrity and legality of both read values and versions need not be maintained. Indicus maintains \textit{Byz-I} for Isolation level Serializable.\\

Next, we define an ideal progress property to limit the influence byzantine participants have on honest clients \fs{previously said on: system throughput. But this can be misunderstood to include livenes}. 

\textbf{Byzantine Independence}
Given a protocol $P$ and an honest Client $c$. The result of a request $r$ issued by $c$ cannot be determinsistically decided by byzantine participants.  \\

If the network is controlled by an adversary, this property is unattainable for Indicus.\footnote{We point out, that all leader-based protocols suffer the same fallacy: A byzantine leader may always frontrun requests. In fact, even with strengthened network assumptions, such a a system could not offer Byzantine Independence. } 
In order to offer this property we must strengthen our assumption on the network. Concretely, while the network may be asynchronous, we assume the adversary does not control the network, and hence, may not reliably impact results \footnote{An exception to this are wide-ranged flooding attacks (ddos) which are beyond the scope of this work.}. 



\subsection{Practical Assumptions on Behaviors}
While we allow clients to act arbitrarily and maintain safety unconditionally, in practice, we do not expect clients to intentfully attempt to circumvent other clients progress via targeted congestion. This is reasonable to assume as a byzantine client requires prior knowledge on honest client transaction patterns and relevant access control in order to artificially increase object contention. 

We further assume that actively detectable byzantine behavior (such as equivocation or other protocol incoherence) is rare as clients are incentivised to maintain standing in a permissioned system. Moreover, we exect an appropriate level of client performance, from both honest and byzantine clients, to qualify for system participation. Untimely behavior may qualify as misbehavior and elicit client expulsion. 

