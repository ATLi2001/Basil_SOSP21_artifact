
There is an increasing tension between the desire to share data online, and the security concerns it entails.
This paper asks the question: how can we enable \textit{mutually distrustful parties} to consistently and reliably
share data, while minimizing centralization?

The ability to share data online offers exciting opportunities.
\iffalse %% the medical record example is for privacy, more related to Obladi, but not BFT Tapir
In the medical domain, for
instance, cloud-based solutions for managing health record offer doctors increased fault-tolerance at lower
cost, and offer patient an easier path to share their medical
history with their entire treatment teams, even when on the road. Opportunities abound in other areas too.
\fi
In banking, systems like SWIFT enable financial institutions to quickly and accurately receive information
such as money transfer instructions; and in manufacturing, online data sharing can improve accountability
and auditing amongst the globally distributed supply chain.

Increased data sharing, however, raises questions of how to \textit{decentralize trust}.
\iffalse
Even when medical records are
encrypted or anonymized, cloud providers or dishonest applications may be able to acquire
sensitive information: for example, tracking the charts accessed by an oncologist can reveal not only whether
a patient has cancer, but also, depending on the frequency of accesses (e.g., the frequency of chemotherapy
appointments), indicate the cancers type and severity.
\fi
Banking institutions must currently place their trust
in the centralized SWIFT’s network to issue payment orders. Sometimes there is even no identifiable source of
trust. Consider the supply chain for the latest iPhone: it spans three continents, and hundreds of different
contractors~\cite{}; neither Apple nor these contractors trust each other, yet all must be willing to agree and share
information about the construction of the same product.


\iffalse %% Yunhao has removed the medical record example
\Yunhao{If I understand correctly, the medical record example is for privacy,
  the banking and the manufacturing example are for trust.
  I can see how BFT solves the later by decentralizing trust, but I cannot
  see how BFT solves the privacy problem. The access pattern of each transaction is visible to all parties.}
\fi

Recognizing this challenge by both the research and industry communities,
much effort has focused
on enabling shared computation between mutually distrustful parties, in the context of byzantine
fault tolerance (BFT), and blockchains.
Systems proposed in the literature of BFT[][] provide the abstraction of
a totally ordered log; the log is agreed upon by the $n$ participants in the system, of which at most $f$ can misbehave.
Each participant executes operations that may touch one to multiple objects in the log.
In the blockchain world,
Bitcoin and Ethureum have become popular distributed computing platforms
providing the same log abstraction and
aiming for decentralizing trust.
Furthermore, Microsoft Azure has launched projects[] that leverage these blockchain platforms and extend the digital transformation
beyond the companies' four walls in a supply chain.

%\Yunhao{This is the first time we mention transactions. I think we should distinguish 2 groups of research: BFT consensus and BFT transactions.}

This paper argues that there exists a fundamental mismatch between the implementation of %the abstraction of
a totally ordered log and the reality of much large-scale distributed processing. Many large-scale distributed
systems consist primarily of unordered and unrelated operations.
For example,
%Alice’s surgery need not be ordered with respect to Bob’s X-rays; likewise,
a product supply chain consists of many concurrent steps
that do not require ordering. Imposing an ordering on non-conflicting operations is not only often
unnecessary, but costly: participants in the shared computation must vote to order operations, store the full state of
the system, and replay the full log for auditing.

While there exists work on mitigating this scalability bottleneck
through sharding~\cite{}, the latent total order requirement introduces unnecessary coordination overhead, as
coordination is performed twice, at the level of individual shards, and across shards. Callinicos~\cite{} and
Omniledger~\cite{}, for instance, runs a full BFT protocol for every operation. This is especially problematic
when workloads are geo-replicated~\cite{}, or when, as in BFT, the replication factor is high.
%\Yunhao{I can see these two are examples of imposing ordering, but cannot see whether they are examples of twice coordination.}
Further, these systems
support transactions under the assumption that their read and write operations are known a priori, which
limits the set of applications that they can support.

As another research trend of mitigating the scalability bottleneck, 
EPaxos[], TAPIR[] and CURP[] only consider the ordering between potentially conflicting operations,
instead of commutative operations.
However, these systems assume the crash-failure model and are non-trivial to be extended to the Byzantine model,
so that they cannot directly solve the problem of data sharing among mutually distrustful parties.

Existing research, in essence, is either attempting to build concurrency control and sharding
functionalities over BFT replication, or integrating these functionalities into a crash-failure replication protocol.
%Existing research, in essence, is attempting to add database-like transactions and sharding
%functionality to a byzantine fault tolerant totally ordered log. We propose instead to flip the problem on its
%head by adding BFT to an efficiently shardable replicated database.
In this paper, we will show how to build these desiring functionality inside a BFT replication protocol.
Specifically, our goal is to \textit{provide the illusion of a centralized shared
log, rather than the non-scalable reality of a totally ordered log.}
