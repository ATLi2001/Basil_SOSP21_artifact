\section{NC's introduction}

This paper presents the design and evaluation of \sys{}, the
first leaderless and scalable key-value store that is robust
to byzantine faults.

Safe and efficient online data sharing among mutually distrustful
parties offers exciting opportunities for a variety of applications,
including healthcare~\cite{}, financial services~\cite{}, supply chain
management~~\cite{} and more~\cite{}. \nc{I understand that you want to move 
to the main point quickly but I think that one example might be useful here still, just
one}. Byzantine fault tolerant (BFT)
systems~\cite{} and permissioned blockchains~\cite{}
are at the center of these new services. These protocols are guaranteed to
produce the same totally ordered log of operations across mutually distrustful
participants. 

Maintaining a totally ordered log of requests, inspite of its appealing simplicity, is problematic. Such an approach is hard to scale and costly to implement. It is, moreover, often unnecessary. Modern distributed applications primarily consist of independent operations that could be executed concurrently. Supply chains for instance, despite their name, are actually complex networks that generate and process logically concurrent transactions.

Existing research recognises this opportunity and attempt to mitigate the aforementioned scalability bottleneck through a combination of sharding~\cite{omniledger,chainspace,callinicos}, cross-shard atomic commit protocols and centralised ordering services~\cite{}. These systems suffer from three primary drawbacks 1) they limit the expressivity of the transactions tthey support~\cite{} 2) they introduce unnecessary coordination across replicas~\cite{} which affects throughput and finally, 3) they often centralises the ordering of requests at a single leader, which raises fairness concerns. These limitations all stem from the same fallacy: the mistaken belief that building out a total order of operations is necessary for correctness.
 
In reality, building \textit{the abstraction} of a total order is sufficient, and distributed databases have long recognised this fact. Serializability, the gold-standard database criterion, defines a correct execution as one that is \textit{equivalent} to a correct schedule. This definition allows concurrent operations to execute in parallel, restricting any ordering to conflicting operations only.  Byzantine systems need be no different.

This paper consequently argues for a paradigm "flip". The right way to build data-sharing systems for distrustful parties is not to layer database-like transactions and sharding on top of the reality of byzantine fault tolerant log, but instead to build out the abstraction of a BFT log on top of a partially ordered distributed database.
To this effect, we design \sys{}, the first leaderless and scalable BFT key-value store
and provide the first formal definition of byzantine serializabililty. \sys{} provides three main benefits.

 First, it overcomes the scalability bottleneck of a low-level
implementation based on a totally ordered BFT log. \sys uses a
client-driven protocol that bypasses the ordering bottleneck and
leverages databases' ability, honed over decades of research in
concurrency control, to support highly concurrent transaction
processing over a sharded database while retaining, to ease reasoning
about correctness, the capacity to generate executions equivalent to a
total order of commmitted transaction.

% an explicit ordering service 

Second, by doing away with an underlying totally ordered log, \sys{} can
sidestep the growing concerns~\cite{} about whether blockchains
order transactions fairly. Though the notion of fairness in this
context has not been rigorously defined, leaving the ordering to the
whim of a potentially Byzantine leader, as some protocols do~\cite{}
is intuitively problematic; to limit its discretion, other protocols
rotate the leader's responsibility, thus reducing, but not
eliminating, the skew it can introduce. In contrast, \sys leaves the
responsibility of driving the replication and distributed commit of a
transaction to the client that proposes it, and allows different
shards to order transactions in different orders, as long asways, as
long as serializability can be maintained.

Third, it avoids the duplicate ordering costs of transactional systems
built on top of state machine replication. As Tapir noted~\cite{},
these systems require, for replication, a consistent ordering of
operations within each shard, and additionally enforce, for
distributed commit, a serial order of transactions across
shards~\cite{}. In contrast, \sys{} integrates distributed commit and
replication through an optimistic concurrency control (OCC)~\cite{} protocol, to
limit coordination only to the validation step of the distributed commit
protocol---and does so in in a setting where clients, as well as a
fraction of the replicas in each shard, can behave maliciously.

In practice, reaping these benefits requires us to address several
technical obstacles. As in any OCC-based protocol, \sys
is vulnerable to aborts if transactions interleave unfavorably during
validation---but these concerns are compounded in a Byzantine
setting. First, since reading from a single local replica can no
longer guarantee integrity, it becomes necessary to read remotely,
thus increasing the window of time during which unfortunate
interleavings may occur. Second, Byzantine clients and replicas may
collude to actively sabotage the commit chances of transactions issued
by correct clients. 

Byzantine behaviour in effect introduces a tension that is not present in non-byzantine
distributed databases: optimistic and aggressive concurrency control mechanisms known
to improve performance (~\cite{occ,mvtso,pipeline,tapir}) in failure-free executions also increase the system's vulnerability to byzantine faults \nc{give example?}. To mitigate this tension, we design \sys{} to follow the ethos of \textit{independent operability}: both safety (namely, serializability) (the ability to issue and complete tranactions)
are \textit{local} properties. They remain, at all times, per clients and per-object.
 
\nc{Things to mention: we design a version of mvtso that still allows writes to be made visible early but allows clients to finish each other's transactions if a byz client tries to stall the system. If a Byz client tries to stall the system, the fallback is per objet only.
We are leaderless, we have linear cost everywhere}

In summary, we make the following three contributions: 
\begin{itemize}
\item definition of byzantine serializability
\item  byzantine mvtso + per-object concurrent view change?
\item system?
\end{itemize}

Nonetheless, our system has the following limitations ...

The rest of the paper is structured as follows ...

