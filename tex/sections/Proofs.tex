%-------------------------------------------------------------------------------
\section{Proofs}
%-------------------------------------------------------------------------------

\begin{theorem}[1]
The set of transactions for which the MVTSO-Check returns Commit is Byzantine-Serializable. 
\end{theorem}
\begin{proof}

We first show, that the MVTSO-Check never returns Commit for two conflicting transactions TX1 and TX2.
WLOG, assume that TX1 is validated before TX2 and MVTSO-Check(TX1, TX1.TS) returns Commit. This implies that all reads and writes of TX1 are \textit{Prepared}.
We show by case distinction that TX2's validation cannot return Commit:
\begin{itemize}

\item \textbf{TX1.TS < TX2.TS} By timestamp order, the excution results of TX1 and TX2 should be equivalent to a serial schedule in which TX1 happened \textit{before} TX2. A conflict only arises, if TX2 performed a read that should have seen TX1's write, i.e. if TX2's $read.version < TX1.TS$. By lines 3-7 TX2 must Abstain/Abort since TX1 $\in Prepared$. 

\item \textbf{TX1.TS > TX2.TS:} By timestamp order, the excution results of TX1 and TX2 should be equivalent to a serial schedule in which TX1 happened \textit{after} TX2. A conflict only arises, if TX2 attempts to write a version that TX1 should have observed, i.e. if TX1's $read.version < TX2.TS$. By lines 8-10 TX2 must Abstain/Abort since TX1 $\in Prepared$. 
\end{itemize}

We now show, that every honest clients transaction is \textit{legal}, i.e. its reads are based on committed writes. This follow straightforward from Execution protocol: An honest client only reads values that are either committed, or optimistically reads by claiming a dependency on uncommitted writes. By lines 14-18, a TX with dependencies only Commits if all of its dependencies Commit, implying that it read committed writes.

Consequently, all honest clients experience Serializability, and thus, the MVTSO-check maintains Byzantine-Serializability.
\end{proof}

\fs{should split this between Slow and Fast Path. Logged decisions are only slow path. Fast Path implies that the only logged decisions that are possible will be consistent}
\fs{redefine logged decision: 3f+1 correct replicas have adopted a decision. Define shard-certificate: set of decisions that implies existance of a logged decision.}
\begin{theorem}[Saf]
A logged decision is durable, and there can ever exist \textbf{at most one} logged decision.
\fs{Clarify the point of this: We preserve consistency of writeback commit/abort. That in turn follows from the logged decision durability.}
\end{theorem}
\begin{proof}

We show this by case distinction over Slow- and Fast-Path execution. \textbf{Slow-Path}: A Slow-Path decision is \textit{logged} if $\frac{n+f+1}{2} = 3f+1$ ($LoggedQuorum$) honest replicas have adopted the decision, since $n-f = 4f+1$ votes suffice to form a Shard-Certificate and $f$ byzantine participants may decide arbitrarily. Thus it is impossible for two Slow-Path logged decisions to co-exist, as any two $LoggedQuorums$ must intersect in $f+1$ honest replicas that will only ever accept one decision - a contradiction. Furthermore, honest replicas do not change their decision, and hence a slow-path logged decision is durable. \textbf{Fast-Path}: We distinguish three sub-cases. \one A Fast-Path commit shard-certificate requires the existance of $4f+1$ Phase1 honest commit votes. This implies that any Slow-Path execution must result in a commit decision, since there cannot exist $f+1$ Abort votes and client waiting for up to a Vote Set Quorum ($n-f = 4f+1$) is bound to receive $3f+1$ commit votes. \two Vice versa, by Quorum intersection, the existance of $3f+1$ Phase1 abort votes implies the impossibility of any Slow-Path commit decision. 
Trivially, cases \one and \two  mutually exclude each other. 
\three Lastly, 1 Abort vote with valid proof of conflict against a committed transaction implies the existance of a logged commit decision for the conflicting transaction. \fs{Defer this proof to the next theorem... redundant}
By Induction, the conflicting transaction has stored a commit vote or decision at $\geq 3f+1$ correct replicas. Thus, $\geq 3f+1$ correct replicas will vote to Abort the ongoing transaction, hence precluding the existance of $\geq 3f+1$ commit votes and the possibility to ever log a commit decision for the ongoing Transaction.


\end{proof} 

Note, that since replicas never change their decision, it is possible for there to never be any logged decision if a byzantine client equivocated its Slow-Path Quorums. In order to reconcile this, we design and discuss a recovery mechanism in section X which relaxes the requirement for durability of decisions.  


\begin{theorem} 
Indicus maintains \textit{Byzantine-Serializability}.
\end{theorem}
To prove that this is the case, we show that for any two conflicting transactions, at most one can be committed.
\begin{proof}

Let $TX_1$ be a transaction with logged decision \textit{Commit}, i.e. $TX_1$ has either already committed at or is bound to commit at all honest replicas. Let $TX_2$ be a conflicting transaction, that if committed would violate Byzantine-Serializability. Assume $TX_2$ too, managed to log a commit decision. By the protocol, at least  $\frac{n+f+1}{2} = 3f+1$ commit votes are required to log a commit decision, and no honest replica changes its vote. By Quorum intersection, at least one honest replica must have voted commit for both $TX_1$ and $TX_2$. WLOG, this replica received $TX_1$ before $TX_2$. By the correctness of the MVTSO-check (\ref{Theorem1}, must have voted Abort for TX2. A contradiction.


\end{proof}

\begin{theorem} 
Indicus maintains Byzantine Independence in the absence of network adversary.
\end{theorem}

We show, that once a Client submits a transaction for validation, the result cannot be unilaterally decided by any group of (colluding) byzantine participant, be it client or replica.
\begin{proof}

First, we observe that a client may never autonomously determine a result itself, and may only influence the decision value by choice of Fast- or Slow-Path Quorum. Specifically, a byzantine client cannot single-handedly decide to abort its own transaction once submitted for validation, and consequently, cannot single-handedly force potentially dependent transactions to abort as well. 
Second, any Quorum decision requires at least one honest replicas vote. In particular, $f$ byzantine replicas may arbitrarily vote to abort (e.g. by reactively generating and injecting a ficticious, conflciting transaction), but at least one additional correct replicas' abort vote is necessary to result in an abort decision. 
Thus, in order to artificially cause transactions to abort, a conflicting transaction must be generated (artificial congestion). However, to do so strategically and reliably \fs{deterministically}, the adversary must control the network in order to guarantee the artifical transactions arrival at honest replicas \textit{before} the original transaction. 

Likewise, colluding clients may attempt to abort each other in order to cause a correct clients' dependency to abort. For example, they may attempt to schedule the arrival of two conflicting transactions out of order across replicas. To preemptively setup such a targeted trap however, colluding clients must a) know the to-be-victim transactions read keys, and b) race the respective transaction for arrival order. Doing so deterministically requires control of the network.

Thus, when the network is not adversarial, validation decisions are \textit{Byzantine Independent}.

\fs{need to add the case of dependency trying to get aborted by its own dependent. this too is up to the network: A byz replica does not know that there is a dependent until the exceptions or prepares are being issued. needs to have network control in order to still abort. if there are multiple levels then the colluders could already pre-abort each other: example: out of order at 3 replicas each. any TX coming after that claims a dep is doomed. But this is not deterministic: it requires preemtive setup, but keys are not known}


\end{proof}


\begin{theorem}[Liv] 
Every transaction that an honest client is \textit{interested} in eventually completes.
\fs{Clarify: Exactly one shard-decision exists. I.e. Safety is maintained, but there will be one decision. }
\end{theorem}

\begin{proof}
First, we note, that a timely client can trivially complete all of its own transactions that have no dependencies. However, if a client is slow, or its transaction has dependencies, it may lose autonomy over its own transaction. For a given client c, we define the set \textit{Interested$_c$} to include its own tansactions and all their dependencies, as well as any other arbitrary transactions whose completion a client is interested in. 

We distinguish two cases for each $TX \in Interested_c$ that has timed out on its orignial client: 
1) An interested client manages to receive a shard-certificate by either re-issuing a $Phase1$ message and receiving a Fast-Path Threshold of $Phase1R$ messages, or by issuing a new $Phase2$ message and receiving a Slow-Path Quorum of $Phase2R$ messages. In this case, a client is able to complete the transaction as any client may issue the Writeback. Saf is maintained as this case follows the normal-case protocol operation.\\

2) An interested client cannot obtain shard-certificate and starts a Fallback invocation. By Lemma1, given synchrony, a correct Fallback replica will be elected after at most $f+1$ election rounds. Such a Fallback replica will reconcile a consistent decision across all replicas, thus allowing the interested client to receive a Slow-Path Quorum of $Phase2R$ messages (matching decisions, matching views) as shard-certificate, allowing it to complete the Writeback phase. By Lemma2, this decision is consistent with any potential past shard-certificate that may have existed.

\end{proof}



\begin{lemma}
Given weak synchrony, Fallback election is live and non-skipping.
\end{lemma}

\underline{\textbf{View Change Rules:}} \one Replicas only adopt a view $v+1$ if the view set includes $3f+1$ votes from view $v$. \textit{Vote subsumtion:} A view $v$ may count as a vote for all $v' \leq v$. \two Replicas that lag behind, may safely skip ahead to the maximum view $v$ present $f+1$ times, since, by induction, $\geq 3f+1$ replicas must have claimed to be in a view $\geq v-1$. \\
We note, that replicas enforce exponential time-outs on each new tenure: A replica will not adopt a new view and start a new election, until the previous view leader (client or Fallback replica) has elapsed its time-out.

\begin{proof}
A client must provide $3f+1$ matching view responses in order for replicas to adopt the next view and start an election. This implies, that for each correct replica in view $v$, there must exist at least $2f+1$ correct replicas in view $\geq v-1$ (A).
If a client cannot receive such a Quorum, e.g. due to temorary view inconsistency, it must reconcile the views first. This is possible in a single step: By (A) any set of $4f+1$ replica responses must contain $\geq f+1$ correct replicas' votes for a view $v' \geq max(correct.views) -1 $. 
Thus, in the presence on a correct interested clients, and when time-outs grow large enough to enforce synchrony, Byzantine clients cannot stop the successful election of a new Fallback by continuously invoking a view-change. Moreover, election is non-skipping, as a correct client will broadcast a new-view invocation to all replicas. 
\end{proof}

\underline{Practical optimizations:}  In absence of honest interested clients, byzantine clients may invoke fallback elections at a subset of replicas, thus inhibiting true election and skipping select replicas' terms. To avoid artificially increased timeouts and non-skipping candidates, replicas may forward the $ElectFB$ message to all other replicas. Replicas that receive $f+1$ forwarded messages, adopt larger views, and forward the $ElectFB$ message themselves, thus ensuring that all correct replicas adopt each new view, and a Fallback replica is successfully endorsed.
This optimization is not necessary for "theoretical" liveness as shown by Lemma1. To avoid unecessary all-to-all communication, it may only be enforced for views $v > T$, where T is a system hyperparameter.\\

%%%%%%%%%%%%%%%%




\begin{lemma}
The Decision Reconciliation Rule maintains both Saf and Byz-Serializability.
\end{lemma}

The Fallback mechanism extends the requirment for shard-certificates to match in both decisions and views. Consequently, a logged decision is a pair of (decision, view) that, at one point in time, is adopted by $\geq 3f+1$  correct replicas.

\textbf{Decision Reconciliation Rule:} \textit{dec$_{new}$ $=$ maj(\{Elect.decision\})}. Note, that for decision reconciliation, the associated view of a decision is explicitly irrelevant.

\begin{proof} If a logged decision exists, i.e. $3f+1$ correct replicas have adopted the same decision, any Quorum of $4f+1$ Elect messages is guaranteed to contain $2f+1$ matching decisions (a majority). Thus, by the Decision Reconciliation Rule, the only new decision possible is the previously logged decision. By induction, this hols for all consecutive views: If there ever existed a logged decision $d$ in view $v$, then all $dec_{v' > v} = d$. Consequently, Elect messages for future, higher views, do not need not match in their decision views.

If no logged decision existed, then any majority decision qualifies. This is consistent with Byz-Serializability since the majority decision contains $\geq f+1$ correct replicas, which would only have agreed to a decision on the basis of a matching Quorum of $Phase1R$ messages.
\end{proof}

\textit{Aside:} If shard-certificates were not required to match in views, Saf would be violated. Consider an example in which for a view $v$ half of the replicas have adopted decisions Commit/Abort respectively. Let $P_1$ (Commit) and $P_2$ (Abort) be the partitions of replicas with matching votes. A Byzantine Fallback may use two Elect Quorums with different majorities to send $dec_{v+1}$ = Abort to $P_1$, and $dec_{v+1}$ = Commit to $P_2$. Then shard-certificates for both Commit/Abort could exist by using $P_1$ from view $v$ and $P_2$ from view $v+1$, and vice versa, violating Saf. 