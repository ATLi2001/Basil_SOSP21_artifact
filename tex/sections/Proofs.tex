%-------------------------------------------------------------------------------
\section{Proofs}
%-------------------------------------------------------------------------------

\begin{theorem}[1]
The set of transactions for which the MVTSO-Check returns Commit is Byzantine-Serializable. 
\end{theorem}
\begin{proof}

We first show, that the MVTSO-Check never returns Commit for two conflicting transactions TX1 and TX2.
WLOG, assume that TX1 is validated before TX2 and MVTSO-Check(TX1, TX1.TS) returns Commit. This implies that all reads and writes of TX1 are \textit{Prepared}.
We show by case distinction that TX2's validation cannot return Commit:
\begin{itemize}

\item \textbf{TX1.TS < TX2.TS} By timestamp order, the excution results of TX1 and TX2 should be equivalent to a serial schedule in which TX1 happened \textit{before} TX2. A conflict only arises, if TX2 performed a read that should have seen TX1's write, i.e. if TX2's $read.version < TX1.TS$. By lines 3-7 TX2 must Abstain/Abort since TX1 $\in Prepared$. 

\item \textbf{TX1.TS > TX2.TS:} By timestamp order, the excution results of TX1 and TX2 should be equivalent to a serial schedule in which TX1 happened \textit{after} TX2. A conflict only arises, if TX2 attempts to write a version that TX1 should have observed, i.e. if TX1's $read.version < TX2.TS$. By lines 8-10 TX2 must Abstain/Abort since TX1 $\in Prepared$. 
\end{itemize}

We now show, that every honest clients transaction is \textit{legal}, i.e. its reads are based on committed writes. This follow straightforward from Execution protocol: An honest client only reads values that are either committed, or optimistically reads by claiming a dependency on uncommitted writes. By lines 14-18, a TX with dependencies only Commits if all of its dependencies Commit, implying that it read committed writes.

Consequently, all honest clients experience Serializability, and thus, the MVTSO-check maintains Byzantine-Serializability.
\end{proof}

\fs{should split this between Slow and Fast Path. Logged decisions are only slow path. Fast Path implies that the only logged decisions that are possible will be consistent}
\fs{redefine logged decision: 3f+1 correct replicas have adopted a decision. Define shard-certificate: set of decisions that implies existance of a logged decision.}
\begin{theorem}[Saf]
A logged decision is durable, and there can ever exist \textbf{at most one} logged decision.
\fs{Clarify the point of this: We preserve consistency of writeback commit/abort. That in turn follows from the logged decision durability.}
\end{theorem}
\begin{proof}

We show this by case distinction over Slow- and Fast-Path execution. \textbf{Slow-Path}: A Slow-Path decision is \textit{logged} if $\frac{n+f+1}{2} = 3f+1$ ($LoggedQuorum$) honest replicas have adopted the decision, since $n-f = 4f+1$ votes suffice to form a Shard-Certificate and $f$ byzantine participants may decide arbitrarily. Thus it is impossible for two Slow-Path logged decisions to co-exist, as any two $LoggedQuorums$ must intersect in $f+1$ honest replicas that will only ever accept one decision - a contradiction. Furthermore, honest replicas do not change their decision, and hence a slow-path logged decision is durable. \textbf{Fast-Path}: We distinguish three sub-cases. \one A Fast-Path commit shard-certificate requires the existance of $4f+1$ Phase1 honest commit votes. This implies that any Slow-Path execution must result in a commit decision, since there cannot exist $f+1$ Abort votes and client waiting for up to a Vote Set Quorum ($n-f = 4f+1$) is bound to receive $3f+1$ commit votes. \two Vice versa, by Quorum intersection, the existance of $3f+1$ Phase1 abort votes implies the impossibility of any Slow-Path commit decision. 
Trivially, cases \one and \two  mutually exclude each other. 
\three Lastly, 1 Abort vote with valid proof of conflict against a committed transaction implies the existance of a logged commit decision for the conflicting transaction. \fs{Defer this proof to the next theorem... redundant}
By Induction, the conflicting transaction has stored a commit vote or decision at $\geq 3f+1$ correct replicas. Thus, $\geq 3f+1$ correct replicas will vote to Abort the ongoing transaction, hence precluding the existance of $\geq 3f+1$ commit votes and the possibility to ever log a commit decision for the ongoing Transaction.


\end{proof} 

Note, that since replicas never change their decision, it is possible for there to never be any logged decision if a byzantine client equivocated its Slow-Path Quorums. In order to reconcile this, we design and discuss a recovery mechanism in section X which relaxes the requirement for durability of decisions.  


\begin{theorem} 
Indicus maintains \textit{Byzantine-Serializability}.
\end{theorem}
To prove that this is the case, we show that for any two conflicting transactions, at most one can be committed.
\begin{proof}

Let $TX_1$ be a transaction with logged decision \textit{Commit}, i.e. $TX_1$ has either already committed at or is bound to commit at all honest replicas. Let $TX_2$ be a conflicting transaction, that if committed would violate Byzantine-Serializability. Assume $TX_2$ too, managed to log a commit decision. By the protocol, at least  $\frac{n+f+1}{2} = 3f+1$ commit votes are required to log a commit decision, and no honest replica changes its vote. By Quorum intersection, at least one honest replica must have voted commit for both $TX_1$ and $TX_2$. WLOG, this replica received $TX_1$ before $TX_2$. By the correctness of the MVTSO-check (\ref{Theorem1}, must have voted Abort for TX2. A contradiction.


\end{proof}

\begin{theorem} 
Indicus maintains Byzantine Independence in the absence of network adversary.
\end{theorem}

We show, that once a Client submits a transaction for validation, the result cannot be unilaterally decided by any group of (colluding) byzantine participant, be it client or replica.
\begin{proof}

First, we observe that a client may never autonomously determine a result itself, and may only influence the decision value by choice of Fast- or Slow-Path Quorum. Specifically, a byzantine client cannot single-handedly decide to abort its own transaction once submitted for validation, and consequently, cannot single-handedly force potentially dependent transactions to abort as well. 
Second, any Quorum decision requires at least one honest replicas vote. In particular, $f$ byzantine replicas may arbitrarily vote to abort (e.g. by reactively generating and injecting a ficticious, conflciting transaction), but at least one additional correct replicas' abort vote is necessary to result in an abort decision. 
Thus, in order to artificially cause transactions to abort, a conflicting transaction must be generated (artificial congestion). However, to do so strategically and reliably \fs{deterministically}, the adversary must control the network in order to guarantee the artifical transactions arrival at honest replicas \textit{before} the original transaction. 

Likewise, colluding clients may attempt to abort each other in order to cause a correct clients' dependency to abort. For example, they may attempt to schedule the arrival of two conflicting transactions out of order across replicas. To preemptively setup such a targeted trap however, colluding clients must a) know the to-be-victim transactions read keys, and b) race the respective transaction for arrival order. Doing so deterministically requires control of the network.

Thus, when the network is not adversarial, validation decisions are \textit{Byzantine Independent}.

\fs{need to add the case of dependency trying to get aborted by its own dependent. this too is up to the network: A byz replica does not know that there is a dependent until the exceptions or prepares are being issued. needs to have network control in order to still abort. if there are multiple levels then the colluders could already pre-abort each other: example: out of order at 3 replicas each. any TX coming after that claims a dep is doomed. But this is not deterministic: it requires preemtive setup, but keys are not known}


\end{proof}


\begin{theorem}[Liv] 
Every transaction that an honest client is \textit{interested} in eventually completes.
\end{theorem}

\begin{proof}
First, we note, that a timely client can trivially complete all of its own transactions that have no dependencies. However, if a client is slow, or its transaction has dependencies, it may lose autonomy of its own transaction. For a given client c, we define the set \textit{Interested$_c$} to include its own tansactions and all their dependencies, as well as any other arbitrary transactions whose completion a client is interested in. 

We distinguish two cases for each $TX \in Interested_c$ that has timed out on its orignial client: 
1) Client manages to receive shard-certificate using base-protocol (then its no different than a tx of its own, Saf holds from above rules)
2) Client cannot obtain shard-certificate and starts Fallback
We will show that the Fallback mechanism is Safe and Live.
Safety: Follows straightforward from Lemma1
Liveness: Follows straightforward from Lemma2



-proof that election is secure. : logged decision stays durable and at most one, but replica decisions can change.


\begin{lemma}
The Decision Reconciliation Rule maintains Saf.
\end{lemma}

\textbf{Decision Reconciliation Rule:} \textit{dec$_{new}$ $=$ maj(\{Elect.decision\})}. 

\begin{proof} If a logged decision exists, i.e. $3f+1$ correct replicas have adopted the same decision, any Quorum of $4f+1$ Elect messages is guaranteed to contain $2f+1$ matching decisions (a majority). Thus, by the Decision Reconciliation Rule, the only new decision possible is the previously logged decision. Furthermore, decisions used for reconciliation need not match in views: If there ever existed a logged decision $d$ with matching views, then all future $dec_{new} = d$.\\

 Otherwise, an arbitrary decision qualifies since at least one honest replica must have agreed to it.
\end{proof}
 


\begin{lemma}
Given weak synchrony, Fallback election is live 
\end{lemma}
- proof that election is live:
- after f+1 (in synchronous window) rounds correct leader will be elected.

\underline{\textbf{View Change Rules:}} \one Replicas only adopt a view $v+1$ if the view set includes $3f+1$ votes from view $v$. \textit{Vote subsumtion:} A view $v$ may count as a vote for all $v' \leq v$. \two Replicas that lag behind, may safely skip ahead to the maximum view $v$ present $f+1$ times, since, by induction, $\geq 3f+1$ replicas must have claimed to be in a view $\geq v-1$. Thus, any possible divergence can be reconciled in a single step, as there must exist a view $v' \geq max(honest.views) -1 $ for which at least $f+1$ honest votes exist in any Quorum of $4f+1$ votes.\\
\underline{Additional subtlelties:} Replicas enforce exponential time-outs for new elections. In absence of honest interested clients, byzantine clients may invoke fallback elections at a subset of replicas, thus inhibiting true election and skipping select replicas' terms. To avoid artificially increased timeouts and non-skipping candidates, replicas may forward the $ElectFB$ message to all other replicas. Replicas that receive $f+1$ forwarded messages, adopt larger views, and forward the $ElectFB$ message themselves, thus ensuring election for each view.
\footnote{This optimization is not necessary for "theoretical" liveness. To avoid unecessary all-to-all communication, it may only be enforced for views $v > T$, where T is a system hyperparameter }\\

%%%%%%%%%%%%%%%%

We distinguish two cases: \one There exists no decisions 
This follows straightforward from the eventual existance of an honest Fallback replica (at most $f+1$ elections) that reconciles all honest replicas.. For any transaction, an interested honest client will eventually receive a shard-decision, and hence the transaction will complete.
\end{proof}