
%-------------------------------------------------------------------------------
\section{Related Work}  
%-------------------------------------------------------------------------------

\paragraph{Consistent Replication}
Indicus offers a replicated, byzantine fault tolerant database that leverages concurrency control and quorum based agreement to maintain isolation guarantees despite its unordered/inconsistent replication layer. 
The majority of prior work instead maintains consistent replication by means of the State Machine Replication (SMR) approach \cite{schneider1990implementing}. Existing replication solutions for the crash failure fault model (Paxos based: \cite{Li2007, Lampson2001, Lamport98Paxos, Lamport2005a, Lamport2005, Lamport01Paxos, Chandra2007} , Zab: \cite{junqueira2011zab}, \cite{van2014vive}  VR: \cite{oki1988viewstampeda, liskov2012viewstamped}, Raft: \cite{ongaro2014search}) as well as the byzantine fault model \cite{lamport2011byzantizing, pires2018generalized, Guerraoui08Next, Kotla04High, bessani2014state, liskov2010viewstamped} (most notably PBFT \cite{castro1999practical}) maintain consistency by achieving consensus on a totally ordered log of requests. They are, in addition, primarily leader-based which introduces additional scalability issues~\cite{epaxos,tapir} as well as fairness concerns. Recent efforts to address this bottleneck can be classified in three ways. Then you have your enforcing PO, fine-grained ordering, sharding}


The seminal \textit{practical} Byzantine Fault Tolerance (PBFT) protocol and its adaptations (cite Zyzzyva, aardvark..) form the cornerstone of most Permissioned Blockchains \cite{Hyperledger, EthereumQuorum, buchman2016tendermint, al2017chainspace, kokoris2018omniledger,  gilad2017algorand, baudet2019state} (Algorand and Omniledger both not permissioned, but lots of PoS blockchains elect validator set that runs pbft basically, mention some traditional blockchains? Bitcoibn, Ehtereum, also total order).

\fs{mention zyzzyva explicitly because of Fast path concept and speculative execution of replicas. Difference: still leaderbased and clients EXPECT replicas to process in order.}


\paragraph{Enforcing Partial Order}
Totally ordered ledgers solve the problem of consistent transaction replication but enforce unecessary coordination/serialization between commutative operations. 
Approaches to reconcile this scalability limitation by inducing only a partial order can be broadly categorized in three ways:
\textbf{1. Fine-grained ordering}: One class of approaches attempts to only order conflicting operations by leveraging transaction semantics. Existing work however (cite all CF: Epaxos, Generalized Paxos, \cite{sutra2011fast}, \cite{li2012redblue}, Curp, Carousel, MDCC, Tapir, Janus) targets almost exlusively the crash failure model. To the best of our knowledge, Bilbos/Clairvoyant is the only BFT system that offers SMR for commutative transactions, but unlike \sys is limited to a static transaction model and introduces blocking, as any transaction must wait for all potentially concurrent transactions to complete. Other quorum based systems whose strucutre \sys resembles (Q/U, H/Q, Liskov rendering harmless) allow for commutativity, but do not offer transactions. \fs{Q/U resembles Logging in \sys - but has no liveness on its own.}

\textbf{2. Sharding} In the blockchain space, sharding has been explored as mechanism to parallelize independent transactions across shards, while relying on total-order primitives within (Omniledger, Chainspace); In \sys we argue however, that inducing a partial order via sharding is merely a limited engineering optimization. Existing work in the crash failure model (Tapir, Ordering Paper, Janus) points out that layering sharding and transactional control on top of replication (cite Spanner?) incurs redundant coordination, and improves performance by integrating both layers. \sys is the first to adopt this rationale in the byzantine fault model.

\textbf{3. DAGs} Lastly, the use of Directed Acyclic Graphs (DAGs) that allow to parallelize agreement instances, has been explored in several permissionless blockchain networks (Iota, Byteball, Ava, overview paper). It remains unclear whether practical applications exist for the permissioned setting - designing a BFT protocol that replicates a DAG instead of a totally ordered ledger is an interesting avenue for future work.


\paragraph{Byzantine Databases}
In \sys we argue that blockchain functionality, i.e. a distributed transactional system, should be captured by a BFT Database (DB). There exist a series of work offering explicit BFT DBs  
cite( Byzantium, Augustus, Callinicios, HRDB, BFT Dur, Databasify Fabric): HRDB offers interactive transactions for a replicated DB, but relies on a trusted shepherd layer. Byzantium designs a middleware system that utilizes PBFT as atomic broadcast (AB) and provides Snapshot Isolation via a primary backup validation scheme. In cite(BFT Dur) Pedone et al. too, rely on AB to design an OCC-architecture similar to \sys. Augustus and Callinicos leverage sharding for scalability by assuming a limited comparison/query/update transaction model and implementing an optimistic and locking based execution model respectively on top of atomic broadcast.
We expand on existing research to 1) be leaderless and more scalable by allowing un-ordered replication rather than AB, 2) provide interactive read-write transactions, and 3) offer sharding for horizontal scaling.
\subparagraph{Byzantine Clients}
Existing work concerned with byzantine clients addresses mechanisms to reduce frequency and severity of client misbehavior (BFT-dur, byzantium, agustus, callinicos, others, byz liskov). We reformulate transactional corectness guarantees in a byzantine setting to be more explicit about byzantine client behavior \fs{too vague} and extend Liskov et al.s (cite rendering byz client harmless) definition of Byz-Linearizability to transactions (Byz-Serializability). 
Lastly, Herlihy (cite) discusses mechanisms to improve fairness in leader-based systems - In \sys we sidestep fairness concerns by being leaderless and instead define Byzantine Independence in order to formalize byzantine influence.











\subsection{details}


Indicus is the first to do blablabla. This section describes related work...

\textbf{Distributed Transactions for benign faults}
A lot of recent effort has gone into designing high throughput and low latency databases that leverage synergies between transaction and replication layer to improve performance. The recently proposed TAPIR transaction protocol leverages redundancy between transaction ordering and replication ordering to reduce total roundtrips, thus reducing latency in wide area networks. TAPIR shares several similarities with our system, most notably the absence of a leader and the resulting unordered validation structure. Like Indicus, TAPIR utilizes optimistic concurrency control to allow for concurrency among commutative transactions while minimizing coordination. When congestion is high however, throughput and tail latency worsen as abort rate grows. Janus avoids transaction aborts by dynamically re-ordering conflicting transactions \cite{mu2016consolidating}. This however, is made possible by assuming one-shot transactions, i.e. fixed read/write keys, and thus reduces the application generality. Another key-value store, Carousel, similarly assumes a restricted Transaction model in order to parallelize execution and validation \cite{yan2018carousel}. CURP too, leverages commutativity in order to reduces replication costs by making requests durable first, and only ordering them later \cite{park2019exploiting}. 

While all of these databases offer low latency replication, they are fundamentally limited to tolerating crash-failures. This strong failure assumption makes them less robust and not suitable for mission-critical services \cite{Abdollah2007}, finance or otherwise highly sensitive data.

\textbf{Byzantine Fault Tolerant Replication} 
\fs{Really not necessary to explain all the different SMR protocols that exists. Rather: Should explain how they could be used to solve the same problem with total order?}
 The problem of tolerating arbitrary failures was originally formalized as \textit{Byzantine Generals Problem} \cite{lamport2019byzantine}, paving the way for countless Byzantine Fault Tolerant (BFT) protocols and implementations \cite{castro1999practical, martin2006fast, kotla2007zyzzyva, pires2018generalized, bessani2014state, lamport2011byzantizing, arun2019ezbft, malkhi2019flexible, duan2014hbft, yin2003separating}. Such protocols have a reputation of being  both notoriously difficult to understand and design correctly \cite{abraham2017revisiting, abraham2018revisiting, shrestha2019revisiting}, and in practice often impose significant overhead compared to its crash-failure tolerant counterparts, hence limiting frequent industrial adoption.
Recently however, with the surge in Blockchain interest, BFT protocols are experiencing a second Spring. While originally developed to tolerate arbitrary bugs, these protocols find increasing importance in settings where participants are untrusted or malicious. Permissioned Blockchains, organized by a consortium of registered participants can use traditional BFT State Machine Replication (SMR) protocols in order to achieve agreement. 
\fs{mention basic BFT first? pBFT is the first "practical", not the first BFT}
The seminal practical BFT (PBFT) protocol \cite{castro1999practical} implements a primary backup scheme that achieves consensus in three broadcast rounds, maintaining safety as long as the number of faulty participants is $<1/3$ (i.e. $n\geq 3f+1$), and offering liveness during synchronous operation. When primaries misbehave, a dedicated \textit{view-change protocol} allows for safe reconciliation. There have been numerous adaptations that aim to speed up common case and failure free execution such as FaB \cite{martin2006fast}, and most notably Zyzzyva \cite{kotla2007zyzzyva} which leverages speculative execution and a semi-client driven protocol to reduce latency. Akin to Indicus, replicas in Zyzzyva speculatively execute requests out-of-order, and rely on honest clients for reconciliation. Zyzzyva replicas however, \textit{expect} to process requests in-order, and diverge only temporarily as result of a byzantine leader. hBFT builds on Zyzzyva and attempts to improve faulty case behavior by returning the client responsibility of detecting inconsistencies to a dedicated replica checkpointing protocol. 
UpRight explores efforts to tolerate both byzantine and crash failures in order to make the overhead of deplyoing a BFT system practical.
SBFT \cite{gueta2018sbft} pursues the goal of scaling to scale to large replication degrees, while offering light clients and high throughput under benign faults. It adopts the UpRight replication model, and modifies PBFT by utilizing collectors, threshold signatures and a fast path akin to Zyzzyva. 
Aardvark \cite{clement2009making} emphasizes the importance of robust performance under byzantine failures by adding increased client and replica checks and imposing frequent leader rotation by steadily increasing throughput requirements. Tendermint \cite{buchman2016tendermint} pushes this idea to the extreme by rotating leaders continuously, at the cost of assuming a synchronous network. Herlihy and Mor attempt to rigorize fairness properties for permissioned Blockchains and propose techniques to increase accountability for Tendermint specifically \cite{herlihy2016enhancing}.

HotStuff too, explores the use of rotating leaders by exploiting the symmetry in PBFTs phases in order to pipeline transaction processing \cite{yin2019hotstuff}. 
Nevertheless, all protocols derived from the PBFT family suffer from the leader bottleneck as well as enforcing a total order even on commutative operations. BFT-Mir \cite{stathakopoulou2019mir} identifies the proposal speed of a single leader as the practical bottleneck in most implementations and improves upon this by allowing all replicas to act as proposers.
Biblos \cite{bazzi2018clairvoyant} achieves leaderless SMR by leveraging a non-skipping timestamp protocol. It furthermore allows for commutative transactions to be executed in parallel at the cost of requiring read/write key sets to be known in advance. In order to preserve liveness however, Bilbos falls back to a PBFT resolution. \fs{Uses all to all, predefined TX, pbft fallback, timestamp phase and proofs required}
The Quorum/Update (Q/U) protocol too, offers leaderless agreement by leveraging Qurorums for a agreement in a limited read/write interface, but fails to terminate under contention \cite{abd2005fault}. To reconcile this shortocming, the Hybrid Quorum protocol (HQ) explores a hybrid solution, extending upon Q/U by adding a PBFT fallback path under contention \cite{cowling2006hq}. In \cite{liskov2006tolerating}, Liskov et Al explore improved byzantine Quorum protocols for a single Read/Write interface, giving special attention to bounding the effects of byzantine clients. 
\fs{BFT protocols under fire: \cite{singh2008bft} that one-size-fits-all protocols may be hard if not impossible to design in practice}
All of the above systems, including Indicus, guarantee Liveness only under the assumption of some degree of synchrony. This is consistent with the well known FLP impossibility result stating that no deterministic consensus solution may exist in the presence of asynchrony \cite{fischer1985impossibility}. Protocols such as Ben-Or's algorithm \cite{ben1983another}, HoneybadgerBFT \cite{miller2016honey} or BEAT \cite{duan2018beat} sidestep this result by introducing randomization, thus enabling probabilistic agreement even during asynchrony.

\textbf{BFT distributed transactions}
While the literature on BFT state machine replication is extensive, the efforts to offer a transactional interface for BFT are scarce. SMR itself can be utilized as a straw-man system to implement pre-defined Transactions (one-shot or stored procedures) by enforcing a common total order in which replicas will execute the transactions. \fs{Byz agreement apps for DB \cite{garcia1986applications}}
HRDB offers a dedicated BFT Database, but assumes a trusted shepheard layer, thus not being truly BF resilient \cite{vandiver2007tolerating}.
Byantium \fs{middleware stuff} offers Snapshot Isolation for Transactions by re-purposing PBFT as atomic broadcast. It executes requests only at a primary and uses replicas to validate results in the total order defined by the SMR protocol \cite{garcia2011efficient}. Augustus implements short-transactions, a limited, comparison/query/update transaction model that declares all operations before execution \cite{padilha2013augustus}. It offers scalability via partitioning and achieves consistency within partitions by utilizing atomic broadcast. While Augustus assumes an optimistic execution model that allows for aborts under concurrency, its follow up work Callinicos implements a locking scheme in order to avoid Transaction aborts \cite{padilha2016callinicos}. To do so efficiently it resorts to a limited transaction model that requires knowledge of read/write sets and otherwise locks an entire partition in order to guarantee mutual exclusion, thus voiding any concurrency. BFT Deferred Update Replication adopts an interactive OCC transaction model comparable to ours, allowing execution to be speculative at clients \cite{pedone2012byzantine}. However, it uses PBFT as atomic broadcast implementation to enforce SMR on validation, thus resorting to both a leader, and a total order on all requests. It moreover does not extend to multiple shards.

\textbf{Blockchains and Sharding}
In the Blockchain world, Chainspace \cite{al2017chainspace} and Omniledger \cite{kokoris2018omniledger} implement sharding by layering 2PC and atomic broadcast (within shards) for the UTXO transaction model. Rapidchain \cite{zamani2018rapidchain} offers efficient sharding for a permissionless system (what else? didnt read much, not so relevant). Hyperledger provides an enterprise-ready permissioned blockchain solution that simulates optimistic transaction processing by letting replicas speculatively execute Smart Contracts. While Hyperledger \cite{Hyperledger} describes itself as a shared database, it relies on a dedicated SMR ordering service that enforces a total order, and, in practice, only tolerates crash failures (Hyperledger uses Raft \cite{ongaro2014search}, a consensus protocol for the Crash-Failure model,  but can be extended to use PBFT). Sharma et al. attempt to \textit{databaseify} Hyperledger by adding database techniques such as transaction re-ordering in order to reduce aborts, but fundamentally maintains the totally ordered (Hyper-) ledger design \cite{sharma2018databasify}. \fs{Databasify paper: tries to add some bandaid db techniques to hyperledger. Transaction re-ordering (still total order), and early aborts.} 
 \fs{(Mention other Permissioned Blockchain systems: Ethereum Quorum? (uses Raft or IstanbulBFT = implementation of pbft)}

Directed Acylcic Graph (DAG) based consensus architectures \cite{pervez2018comparative}(IoT-chain, IOTA, Byteball - all are blockless) have been explored  in order to parallelize agreement and execution instances. While these approaches increase throughput by inducing a partial order, they target permissionelss settings (based on Proof of Work/Stake), rather than permissioned BFT-based solutions. To the best of our knowledge there exists no such system to this date, and it is unclear how to merge these approaches. Designing a BFT protocol that replicates a DAG instead of a totally ordered ledger is an interesting avenue for future work.






\fs{How does all this related work compare to Indicus?}

