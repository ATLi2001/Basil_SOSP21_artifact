%-------------------------------------------------------------------------------
\subsection{Model and Definitions}
%-------------------------------------------------------------------------------

\subsubsection{System Model}
We assume a partitioned Database where data objects are spread uniformly across shards (randomly or based on locality). For fault tolerance we assume that each Shard contains 5f+1 \fs{fraction - dont need to specify yet} replicas where f is the number of (static) faulty or compromised replicas. A faulty replica may behave in Byzantine fashion, i.e. in addition to crashing or omitting messages it may send arbitrary messages and deviate from prescribed protocols in any way.
We denote any participant (replica or client) that follows the protocol as \textit{honest} \fs{change to correct}, while faulty participants are dubbed \textit{byzantine}. We concede that there may exist a finite but unbounded number of byzantine Clients that may deviate from the protocol arbitrarily. 
 We further assume a strong, but static adversary that can freely coordinate the faulty participants.
 We do, however, assume the existance of sufficiently hard cryptographic primitives that allow for private/public key signatures and collision-resistant hashes that cannot be compromised by byzantine participants. We denote a signed message $m$, signed by principal $p$ as $\langle m \rangle_{\sigma p}$. \fs{probably cut the sigma, i omitted it in many places}\\
 
We make no assumption on network synchrony in order to maintain safety, but in some cases may provide liveness  only when the network is synchronous and messages are delayed by no more than a fixed but potentially unknown window \fs{whats a window}. This is consistent with known impossibility results \cite{fischer1985impossibility}.
However, unlike traditional State Machine Replication protocols in which the liveness of all Clients is correlated with the fate of the system (or often more specifically a leader), our system guarantees liveness not on a system basis, but on a per client basis. Concretely, we only guarantee liveness to clients that follow the protocol. Conversely, an honest client only loses liveness (even in an asynchronous setting \fs{i guess this is not fully true and should be cut: If a client is "slow", i.e. messages are async it may lose control of its own tx, byzantine clients can take over}) when it intertwines its fate with byzantine clients.\\

Application services may restrict the influence of Byzantine Clients on the Database state by authentication and enforcing access control. Beyond these measures, byzantine Clients that follow the protocol are indistinguishable from honest clients and may read and write at their leisure. While potential damage to the Database state cannot be avoided, it can be re-traced by auditing the transaction logs.\\


