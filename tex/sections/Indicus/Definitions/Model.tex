%-------------------------------------------------------------------------------
\section{Model and Definitions}
%-------------------------------------------------------------------------------


\subsection{System Model}
We assume the Byzantine Fault Model, in which faulty participants (we distinguish replicas and clients) can (mis-) behave arbitrarily. We denote any participant that follows prescribed protocols as \textit{honest} \fs{lorenzo prefers "correct"}, while faulty participants are dubbed \textit{byzantine}. The database may be partitioned into several replication groups (shards), each of which tolerates a fixed fraction of byzantine replicas. We further assume that there may exist a finite but unbounded number of byzantine clients, and the existance of a strong, but static adversary that can freely coordinate all byzantine participants. We do assume however, the existance of sufficiently hard cryptographic primitives that allow for private/public key signatures and collision-resistant hashes that cannot be compromised by byzantine participants. We denote a message $m$, signed by principal $p$ as $\langle m \rangle_p$. 
 
We make no assumption on network synchrony in order to maintain safety, but in some cases, consistent with known impossibility results \cite{fischer1985impossibility}, may provide liveness only when the network is synchronous and messages are delayed by no more than a fixed but potentially unknown time frame. 
Unlike traditional State Machine Replication protocols in which the liveness of all Clients is correlated with the fate of the system (or often more specifically a leader), our system guarantees liveness not on a system basis, but on a per client basis. Concretely, we only guarantee liveness to clients that follow the protocol. Conversely, an honest client only loses liveness when it intertwines its fate with byzantine clients.\\

Application services may restrict the influence of byzantine clients by enforcing authentication and access control. While potential damage to the database state through authenticated clients cannot be avoided, it is re-traceable by auditing transaction logs.\\
