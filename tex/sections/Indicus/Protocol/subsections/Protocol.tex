\sys{} takes as its starting point an aggressive multiversioned concurrency control,
MVTSO, and modifies it in three ways: \one~it has the client drive the protocol execution,
thus removing all centralised system components \two~it merges concurrency control
with replication and consequently removes duplicate coordinations present in prior approaches~\cite{}, and finally \three~it hardens the protocol against Byzantine attacks to guaranteeByzantine serializability while preserving independent operability.

\par \textbf{MVTSO} Traditional MVTSO works as follows. A transaction $t$ is assigned (usually by a transaction manager or scheduler) a unique timestamp $t_{ts}$ that determines its serialization order. As MVTSO is a multiversioned system, every write operation creates a new version of every object and timestamps it with its encompassing transaction's timestamp $t_ts$. Read operations for $t$ return the version with the largest timestamp that is smaller than $t_{ts}$. Read operations mark the read object with $t_{ts}$ (we refer to this as a read timestamp or RTS). Any subsequent write operation belongng to a transaction with a smaller timestamp that tries to write the same object will be subsequently aborted. Read timestamps are key to preserving serializability: they guarantee that no read will miss a write belonging to a transaction that would have preceded it in the serialization order (as all such writes are aborted). MVTSO is an optimistic protocol: it allows read operations to observe the uncommitted writes of ongoing transactions. These read operations acquire \textit{dependencies} on these transactions and abort if any of them fail to commit.   

MVTSO is an optimistic protocol: it assigns a serialization order a-priori through timestamps and expects transactions to closely commit in that order. It additionally optimistically expose write operations under the assumption that transactions are likely to commit. While these features are key to MVTSO's high performance, they also make it more susceptible to Byzantine attacks; a Byzantine client, for instance, could simply start transactions that write to large numbers of keys and never
commit them, thereby blocking subsequent read operations. In the remainder of this section, we describe how we modify MVTSO to preserve its appealing traits while hardening against Byzantine faults.

\par \textbf{Begin()} A client begins a transaction by optimistically choosing a timestamp \textit{TS $\coloneqq$ (Time, ClientID)} that defines a total serialization order across all clients. Allowing clients to choose their own timestamps removes the need for a centralised scheduler. Byzantine clients could actively choose timestamps that differ from real-time. We defend against this by mandating that all replicas accept transaction operations if and only their timestamp is no greater than
$R_{Time} + \delta$, where $R_{time}$ is the replica's own local clock.

\par \textbf{Write(key,value)} As we previously mentioned, making writes visible before commit could Byzantine clients to prevent honest clients' transactions from committing; waiting for a transaction to commit to reveal writes however, increases the probability that transactions will miss the write and abort.  We side-step this issue by buffering writes locally (adding them to the transaction's write set $WriteSet = WriteSet \cup(key,value)$ and making them visible at the \textit{validation phase}. We describe in Section~\ref{}
how this middle-ground allows us to preserve
much of the performance benefit of early visibility while enforcing independent operability.

\par \textbf{Read(key)} In traditional MVTSO, a read for transaction $T$ returns the version with the highest timestamp smaller than $T$. In a replicated setting where replicas process requests independently, this is no longer sufficient: a write could have been made visible at replica $R$ but not $R'$, causing a read to $R$ by transaction $T$ to return a stale value. MVTSO transactions must additionally be validated, as we describe in \S\ref{}. In a Byzantine
setting, however, further care is required as Byzantine replicas could intentionally submit stale (or imaginary!) values that would cause transactions to abort, violating Byzantine independence. The read logic is then as follows:
\fbox{\begin{minipage}{23em}
\textbf{1: C} $\rightarrow$ \textbf{R}: Client sends read request to Replicas
\end{minipage}}\\
%Improve RQS formulation
A client broadcasts a signed read request  $m = (Read, key, TS)_c$ to \textit{all} replicas.
\fbox{\begin{minipage}{23em}
\textbf{2: R} $\rightarrow$ \textbf{C}: Replica processes client read and replies
\end{minipage}}\\
Each replica $R$ validates the signature and checks that the request timestamp is smaller than $R_{Time} + \delta$. Upon success, it updates the key's read timestamp with $T$'s own timestamp. Finally, the replica returns a signed message \text{$\langle \textit{ Committed, Prepared} \rangle _R$} that contains two entries.
The \textit{Committed=(version,proof)} entry contains one the largest \textit{committed} version whose timestamp is smaller than $T$'s, along side a proof that it has committed. A commit proof consists of a \nc{Fill in}(as we describe in Section~\ref{}. The \textit{Prepared=(version,TxId,deps)} entry consists of the largest \textit{prepared} version that satisfies the same timestamp criterion (if any exists), along with the transaction's id \textit{TxId} and its write-read dependencies \textit{deps}.
The need to distinguish between prepared and committed transactions is unique to Byzantine MVTSO and stems, once again, from the need to enforce independent operability as we describe next.

\fbox{\begin{minipage}{23em}
\textbf{3: C} ($\rightarrow$ \textbf{R}): Client receives read replies 
\end{minipage}}\\
A client waits for $f+1$ read replies and chooses the largest \textit{valid} version ($=max_{valid}(\{Committed\},\{Prepared\})$).
A committed version is valid if it associated with a valid proof. 
Reading from $f+1$ replicas ensures that at least one honest replica
was included in the set of results. Taking the maximum version across all responses ensures that a client will never read a version staler than what it could have read when reading from an honest replica (thus guaranteeing Byzantine independence). The validity criterion for prepared versions is more complex: a \textit{Prepared}
version is valid iff there exists $f+1$ matching $Prepared$ entries.
\nc{in the previous section, we talk about the validation phase, and then the writeback phase, but here we talk about prepare requests. Should we maybe switch to prepare and commit phase? or prepare and write back phase at least?} This higher threshold is necessary to prevent honest clients from being stalled by byzantine transactions: if $f+1$ replicas contain a \textit{Prepare} entry for the same transaction $T'$, there is at least one replica that has received a prepare request for that transaction. This honest replica will necessarily finish committing transaction $T'$ through \sys's \textit{fallback} protocol (\S\ref{}), thus allowing any dependency to commit in turn.
Finally, the client adds the chosen version to its read set \textit{ReadSet = ReadSet $\cup$ (key, version)} and additionally claims a dependency if it was a \textit{Prepared} version: \textit{Dep = Dep $\cup$ \{f+1 $\times$ Prepared$_r$ \}}. 

\par \textbf{Commit()} Upon receiving a commit request from the application, the client initiates the validation phase.

\par \textbf{Abort()} Upon instead reading an abort request,
the client sends a message to replicas to remove its read timestamps from all keys in $ReadSet$. No actions need to be taken for writes, as \sys buffers writes during execution.

\subsection{Validation (Prepare?) Phase}
The prepare phase for a transaction $T$ has two-steps: first,
each replica must determine whether committing $T$ would violate serializability. This is a local decision in the form of a concurrency control check. Second, the set of replicas within
each shard must agree to a common decision that will be preserved across failures. 

\par \textbf{Concurrency control check}

\par \textbf{Achieving agreement across replicas}

\subsection{Writeback phase}
