\sys{} takes as its starting point an aggressive multiversioned concurrency control,
MVTSO, and modifies it in three ways: \one~it has the client drive the protocol execution,
thus removing all centralised system components \two~it merges concurrency control
with replication and consequently removes duplicate coordinations present in prior approaches~\cite{}, and finally \three~it hardens the protocol against Byzantine attacks to guarantee Byzantine serializability while preserving independent operability  \fs{and/or Byz Independence?}.

\par \textbf{MVTSO} Traditional MVTSO works as follows. A transaction $T$ is assigned (usually by a transaction manager or scheduler) a unique timestamp $T_{ts}$ that determines its serialization order. As MVTSO is a multiversioned system, every write operation creates a new version of every object and timestamps it with its encompassing transaction's timestamp $T_ts$. Read operations for $T$ return the version with the largest timestamp that is smaller than $T_{ts}$. Read operations mark the read object with $T_{ts}$ (we refer to this as a read timestamp or RTS). Any subsequent write operation belonging to a transaction with a smaller timestamp that tries to write the same object will be subsequently aborted. Read timestamps are key to preserving serializability: they guarantee that no read will miss a write belonging to a transaction that would have preceded it in the serialization order (as all such writes are aborted). \changebars{MVTSO furthermore allows}{MVTSO is an optimistic protocol: it allows} read operations to observe the uncommitted writes of ongoing transactions. These read operations acquire \textit{dependencies} on these \fs{"these" twice sounds weird?} transactions and abort if any of them fail to commit.   

\fs{it is mentioned twice that MVTSO is an optimistic protocol and writes are optimistically exposed.}

MVTSO is an optimistic protocol: it assigns a serialization order a-priori through timestamps and expects transactions to closely commit in that order. It additionally optimistically expose write operations under the assumption that transactions are likely to commit. While these features are key to MVTSO's high performance, they also make it more susceptible to Byzantine attacks; a Byzantine client, for instance, could simply start transactions that write to large numbers of keys and never
commit them, thereby blocking subsequent read operations. In the remainder of this section, we describe how we modify MVTSO to preserve its appealing traits while hardening against Byzantine faults.

\par \textbf{Begin()} A client begins a transaction by optimistically choosing a timestamp \textit{TS $\coloneqq$ (Time, ClientID)} that defines a total serialization order across all clients. Allowing clients to choose their own timestamps removes the need for a centralised scheduler. Byzantine clients could actively choose timestamps that differ from real-time. We defend against this by mandating that all replicas accept transaction operations if and only their timestamp is no greater than
$R_{Time} + \delta$, where $R_{time}$ is the replica's own local clock.

\par \textbf{Write(key,value)} As we previously mentioned, making writes visible before commit could Byzantine clients to prevent honest clients' transactions from committing; waiting for a transaction to commit to reveal writes however, increases the probability that transactions will miss the write and abort. We side-step this issue by buffering writes locally (adding them to the transaction's write set $WriteSet = WriteSet \cup(key,value)$) and making them visible at the \textit{validation phase}. We describe in Section~\ref{}
how this middle-ground allows us to preserve
much of the performance benefit of early visibility while enforcing independent operability.

\par \textbf{Read(key)} In traditional MVTSO, a read for transaction $T$ returns the version with the highest timestamp smaller than $T$. In a replicated setting where replicas process requests independently, this is no longer sufficient: a write could have been made visible at replica $R$ but not $R'$, causing a read to $R'$ by transaction $T$ to return a stale value. MVTSO transactions must additionally be validated, as we describe in \S\ref{}. In a Byzantine
setting, however, further care is required as Byzantine replicas could intentionally submit stale (or imaginary!) values that would cause transactions to abort, violating Byzantine independence \fs{or violate Byz Serializability}. The read logic is then as follows:

\fbox{\begin{minipage}{23em}
\textbf{1: C} $\rightarrow$ \textbf{R}: Client sends read request to Replicas
\end{minipage}}

A client broadcasts a signed read request  $m = (Read, key, TS)_c$ to \textit{all} replicas.

\fbox{\begin{minipage}{23em}
\textbf{2: R} $\rightarrow$ \textbf{C}: Replica processes client read and replies
\end{minipage}}

Each replica $R$ validates the signature \fs{the sig here is only for access control purposes} and checks that the request timestamp is smaller than $R_{Time} + \delta$. Upon success, it updates the key's read timestamp with $T$'s own timestamp. Finally, the replica returns a signed message \text{$\langle \textit{ Committed, Prepared} \rangle _R$} that contains two entries.
The \textit{Committed=(version,proof)} entry contains one the largest \textit{committed} version whose timestamp is smaller than $T$'s, along side a proof that it has committed. A commit proof consists of \changebars{a set of replica signatures affirming commitment}{\nc{fill in}} (\fs{concretely, a set of shard-certificates; I.e. a quorum of sigs from each involved shard.} as we describe in Section~\ref{}). The \textit{Prepared=(version,TxId,deps)} entry consists of the largest \textit{prepared} \fs{it needs to be defined somewhere what "prepared" is supposed to mean} version that satisfies the same timestamp criterion (if any exists), along with the transaction's id \textit{TxId} and its write-read dependencies \textit{deps}.
The need to distinguish between prepared and committed transactions is unique to Byzantine MVTSO and stems, once again, from the need to enforce independent operability as we describe next.

\fbox{\begin{minipage}{23em}
\textbf{3: C} ($\rightarrow$ \textbf{R}): Client receives read replies 
\end{minipage}}

A client waits for $f+1$ read replies and chooses the largest \textit{valid} version ($=max_{valid}(\{Committed\},\{Prepared\})$).
A committed version is valid if it associated with a valid proof. 
Reading from $f+1$ replicas ensures that at least one honest replica
was included in the set of results. Taking the maximum version across all responses ensures that a client will never read a version staler than what it could have read when reading from a correct replica (thus guaranteeing Byzantine independence). The validity criterion for prepared versions is more complex: a \textit{Prepared}
version is valid iff there exists $f+1$ matching $Prepared$ entries. 
\nc{in the previous section, we talk about the validation phase, and then the writeback phase, but here we talk about prepare requests. Should we maybe switch to prepare and commit phase? or prepare and write back phase at least?}\fs{If we change it, then I favor Prepare/Commit phase because that corresponds best to 2PC - But I know it confuses lorenzo if it is called Commit phase but the decision is Abort...} This higher threshold is necessary to prevent honest clients from being stalled by byzantine transactions: if $f+1$ replicas contain a \textit{Prepare} entry for the same transaction $T'$, there is at least one replica that has received a prepare request for that transaction. \changebars{This correct replica will necessarily provide the full transaction contents, thereby allowing \text{interested} clients to finish committing transaction $T'$ through \sys's \textit{fallback} protocol (\S\ref{}), and allowing any dependent to commit in turn. Moreover, it guarantees that any valid read version was not reactively fabricated by Byzantine replicas, thus preserving Byzantine Independence. \fs{personally I also feel like its worth mentioning that it give you some confidence that this version could commit, i.e. at least one honest believes so.}}{This honest replica will necessarily finish committing transaction $T'$ through \sys's \textit{fallback} protocol (\S\ref{}), thus allowing any dependency to commit in turn.}
Finally, the client adds the chosen version to its read set \textit{ReadSet = ReadSet $\cup$ (key, version)} and additionally claims a dependency if it was a \textit{Prepared} version: \textit{Dep = Dep $\cup$ \{f+1 $\times$ Prepared$_r$ \}}. 

\par \textbf{Commit()} Upon receiving a commit request from the application, the client initiates the validation phase. \fs{I felt it was good to mention that this corresponds to the Prepare of 2PC - that is in line with your comment earlier to rename the phase.}

\par \textbf{Abort()} Upon instead reading an abort request,
the client sends a message to replicas to remove its read timestamps from all keys in $ReadSet$. No actions need to be taken for writes, as \sys buffers writes during execution.

\subsection{Prepare Phase}
The prepare phase for a transaction $T$ has two-steps: first,
each replica must determine whether committing $T$ would violate serializability. This is a local decision in the form of a concurrency control check. Second, replicas within a shard must reach a global and unanimous decision on whether to commit a transaction that will be preserved across failures.

\par \textbf{Concurrency control check} Traditional, non-replicated, MVTSO does not require any validation as transactions are guaranteed to observe all the writes that precede them in the serialization order (any "late" write is detected by read timestamps and the corresponding transaction is aborted). This is no longer true in a replicated system as reads could have failed to observe a write committing on a different replica. To preserve serializability
and determine whether a transaction $T$ should commit, the concurrency control check proceeds (atomically) in five steps (pseudocode is in Figure~\ref{mvtso}): first, it verifies that the transaction's timestamp is within the replica's timebound (Lines 1-2). Second, it verifies that reads in $T$ did not miss any writes. Specifically, the algorithm (Lines 3-5 )checks that there does exist a write 
from a committed or prepared transaction $TS$ that is more recent than the version that $T$ read but a timestamp $TS$ smaller that $T$ (that $T$ should therefore have observed).
Third, the algorithm verifies that writes in $T$ would not cause reads in \textit{other} prepared
or committed transactions to miss any writes (Lines 7-9). It similarly checks that $T$'s writes would not cause \textit{ongoing} transactions to miss a write by aborting $T$ if there exists an RTS greater than $T$'s timestamp (Line 10). Finally, the algorithm checks that $T$'s dependencies are valid (they contain proof of f+1 matching reads), and waits for these dependencies to finish (Lines 14-20). $T$ commmits if all of its dependencies commits  or otherwise aborts.

\begin{theorem}
The set of transactions for which the MVTSO-Check returns Commit is Byzantine-Serializable. 
\end{theorem}
\begin{proof}
\tr{Proof in Appendix~\ref{}}{Proof in TR~\ref{}}
\end{proof}

\par \textbf{Achieving agreement across replicas} Once each replica has determined whether a transaction should abort or commit, it must reach agreement with all other replicas. \sys{} ensures that this process remains leaderless and preserves independent operability. For performance, \sys{} further allows replicas to process requests out of order while ensuring that the end result is consistent across replicas nonetheless. To achieve this, \sys{} designates clients as the
coordinators for their own transactions, and proceeds in two steps: a first \textit{voting} step ensures that replicas reach consensus on an abort/commit decision, while a second \textit{logging} phase guarantees that the decision will be persisted across failures. Both phases require at most a single round-trip. In the absence of contention or failures, transations can commit on a \textit{fast path} in a single round-trip as an explicit logging round is not
necessary. The protocol is as follows, for a set of 5f+1 replicas and a single shard $S$ \nc{this reminds me that we never actually mention in the intro that we can commit transactions in a single round-trip! Tapir emphasised this so much, we probably want to at least mention it}

\subsection{Writeback phase}
