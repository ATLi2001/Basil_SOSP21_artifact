
\subsubsection{Preserving isolation}

Algorithm \ref{mvtso} shows the necessary concurrency control check to preserve Byzantine-Serializability. 
Given a transactions prepare request \la{This transaction prepare
  request comes a bit out of the blue---it is not discussed explictly
  in the previous section
  as one of the messages being exchanged} the validation check returns
an Abort vote if a conflict has been detected, and Commit
otherwise. \la{For my taste, there are a lot of COmmit flying
  around... can we just call these Yes or No votes, like BHG?}
When execution results match the timestamp order, there are no
conflicts (Fig. \ref{fig:MVTSOEX}: 4 top). For each read, a replica
verifies that it has not voted to commit a conflicting write
(Algorithm \ref{mvtso}, line 3-7). Conversely, for each write, a
replica confirms that there exist no previously accepted reads (line
8-10), \la{line numbers are off} and no ongoing read transactions
(line 11-12) \la{line numbers off} that conflict. Fig. \ref{fig:MVTSOEX}: 4 shows both non-conflicting and conflicting interleavings.
If there are no conflicts, a replica tentatively \textit{prepares} a transaction, making its writes visible and evaluating future transactions against it for conflicts. Regardless of the outcome, a replica garbage collects all Read Timestmaps (RTS) associated with the transactions reads.
It then waits for necessary dependencies (uncommited writes that were read) to be resolved (Figure \ref{fig:MVTSOEX}: 5). We remark, that the concurrency control check is serialized and executed atomically for each transaction.

\begin{theorem}
The set of transactions for which the MVTSO-Check returns Commit is Byzantine-Serializable. 
\end{theorem}
\begin{proof}
\tr{Proof in Appendix~\ref{}}{Proof in TR~\ref{}}
\end{proof}

\iffalse
\begin{proof}
We first show, that the MVTSO-Check never returns Commit for two conflicting transactions TX1 and TX2.
WLOG, assume that TX1 is validated before TX2 and MVTSO-Check(TX1, TX1.TS) returns Commit. This implies that all reads and writes of TX1 are \textit{Prepared}.
We show by case distinction that TX2's validation cannot return Commit:
\begin{itemize}

\item \textbf{TX1.TS < TX2.TS} By timestamp order, the excution results of TX1 and TX2 should be equivalent to a serial schedule in which TX1 happened \textit{before} TX2. A conflict only arises, if TX2 performed a read that should have seen TX1's write, i.e. if TX2's $read.version < TX1.TS$. By lines 3-7 TX2 must Abstain/Abort since TX1 $\in Prepared$. 

\item \textbf{TX1.TS > TX2.TS:} By timestamp order, the excution results of TX1 and TX2 should be equivalent to a serial schedule in which TX1 happened \textit{after} TX2. A conflict only arises, if TX2 attempts to write a version that TX1 should have observed, i.e. if TX1's $read.version < TX2.TS$. By lines 8-10 TX2 must Abstain/Abort since TX1 $\in Prepared$. 
\end{itemize}

We now show, that every correct clients transaction is \textit{legal}, i.e. its reads are based on committed writes. This follow straightforward from Execution protocol: A correct client only reads values that are either committed, or optimistically reads by claiming a dependency on uncommitted writes. By lines 14-18, a TX with dependencies only Commits if all of its dependencies Commit, implying that it read committed writes.

Consequently, all correct clients experience Serializability, and thus, the MVTSO-check maintains Byzantine-Serializability.
\end{proof}

\fi

\begin{algorithm}
\caption{MVTSO-Check(TX, TS)}\label{mvtso}
\begin{algorithmic}[1]
\If{\textit{$TS > localClock + \delta$}} %  || $TS < lowWM$ || $\exists d \in dep: d.TS < lowWM$} } dont mention garbage collection part here, it only confuses
\State \Return Abort
\EndIf

\For{\textit{$\forall key,version \in \textit{TX.RS}$}}
	\If{version > TS} \Return PoM
	\EndIf
        \If{$ \exists TX2 \in Committed \cup Prepared: key \in \textit{TX2.WS} $ \newline
        \hspace*{2em} $\land \, version < \textit{TX2.TS} < TS$}  
          \State  \Return Abort, \textit{TX2, (TX2.CommitProof)}  
         \EndIf  
\EndFor

\For{\textit{$\forall key \in \textit{TX.WS}$}}
        \If{$\exists TX2 \in Committed \cup Prepared:$ \newline 
        \hspace*{2em} $\textit{TX2.RS[key].version} < TS < TX2.TS$} 
          \State  \Return Abort, \textit{TX2, (TX2.CommitProof)}
         
        \EndIf
        \If{$\exists RTS \in key.RTS: RTS > TS$} 
          \State  \Return Abort
       \EndIf
\EndFor
\State Prepared.add(TX) 

\If{$\exists invalid d \in dep$} \Return Pom ~~//no $f+1$ matching
\EndIf
\While{$\exists d \in dep: d \notin CommitLog \cup AbortLog $)}
\State Suspend
\EndWhile

%structure it in a way that is better
\For{\textit{$\forall d \in dep$}}
		\If{$ d \in AbortLog $}
		\State	Prepare.remove(TX)
		\State \Return Abort, \textit{(TX2.AbortProof)}
		\EndIf
\EndFor
\State \Return Commit
\end{algorithmic}

\end{algorithm}

In order to perform the MVTSO-check, a replica maintains several data strucutres: \one It stores read timestamps, read versions alongside the multiversioned write stores for committed and tenative transactions respectively, to provide efficient evaluation of conflicts.
\two In order to confirm dependency outcomes, replicas log proofs for completed transactions in respective Commit and Abort Log sets, that together induce the ledger of all processed transactions. 
\three To avoid busy waiting when dependencies are not yet resolved, a replica temporarily suspends the MVTSO-check for the current transaction, allowing it to process other transactions pending validation. To facilitate this, it keeps track of an additonal transaction to dependents mapping that allows to identify and resume all suspended MVTSO-checks associated with dependents of a completing transaction.

\iffalse

\textit{Aside:} Consistent with our definition of Byzantine-Isolation, byzantine clients may issue ficticious Read-Sets comprised of arbitrary read versions and values. However, these have only limited external effect on concurrent writes. We distinguish two extreme cases: 1) $read.version \rightarrow 0$: This case is equivalent to simply reading stale data, and effectively reduces MVTSO to TSO as conlflicts are evaluated only on basis of the transaction timestamps (i.e. Abort write if: write.TS < read.TS). 2) $read.version \rightarrow read.TS$: In this case there are no conflicts as a write is never "missed" by a previous read.
\fi

In the following section we will show how to design a replicated validation scheme that upholds Isolation guarantees and reaches a single shard decision, even when replicas within a shard validate in different orders.
