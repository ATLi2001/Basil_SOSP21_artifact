syntax = "proto2";

import "store/common/common-proto.proto";
import "store/pbftstore/pbft-proto.proto";

package pbftstore.proto;

message Read {
  required uint64 req_id = 1;
  required bytes key = 2;
  required TimestampMessage timestamp = 3;
}

message ReadReply {
  required uint64 req_id = 1;
  required int32 status = 2;
  required bytes key = 3;
  optional bytes value = 4;
  optional TimestampMessage value_timestamp = 5;
  // The commit proof packed message will contain the
  // txn bytes and the key,value pair must be in the txn's write set
  // The proof that the value was actually committed
  // Could still be stale though (i.e. not most recent)
  optional CommitProof commit_proof = 6;
}

// This is the request sent to the replication layer
message Transaction {
  repeated ReadMessage readset = 1;
  repeated WriteMessage writeset = 2;
  required TimestampMessage timestamp = 3;
  repeated uint64 participating_shards = 4;
}

message TransactionDecision {
  required int32 status = 1;
  required bytes txn_digest = 2;
  required uint64 shard_id = 3;
}

message GroupedSignedDecisions {
  // f+1 decisions
  repeated SignedMessage decisions = 1;
}

message ShardSignedDecisions {
  // Map from shard id to the f+1 decisions
  map<uint64, GroupedSignedDecisions> grouped_decisions = 1;
}

message GroupedDecisions {
  // f+1 decisions
  repeated TransactionDecision decisions = 1;
}

message ShardDecisions {
  // Map from shard id to the f+1 decisions
  map<uint64, GroupedDecisions> grouped_decisions = 1;
}

message GroupedDecision {
  required int32 status = 1;
  required bytes txn_digest = 2;
  oneof decisions_oneof {
    ShardDecisions decisions = 3;
    ShardSignedDecisions signed_decisions = 4;
  }
}

message GroupedDecisionAck {
  required int32 status = 1;
}
