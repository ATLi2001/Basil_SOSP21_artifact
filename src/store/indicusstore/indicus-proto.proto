syntax = "proto2";

import "store/common/common-proto.proto";

package indicusstore.proto;


enum CommitDecision {
  COMMIT = 0;
  ABORT = 1;
}

message SignedMessage {
  required bytes data = 1;
  required uint64 process_id = 2;
  required bytes signature = 3;
}

message Signature {
  required uint64 process_id = 1;
  required bytes signature = 2;
}

message Signatures {
  repeated Signature sigs = 1;
}

message Read {
  required uint64 req_id = 1;
  required bytes key = 2;
  required TimestampMessage timestamp = 3;
}

message GroupedSignatures {
  map<uint64, Signatures> grouped_sigs = 1;
}

message CommittedProof {
  required Transaction txn = 1;
  oneof reply_oneof {
    GroupedSignatures p1_sigs = 2;
    GroupedSignatures p2_sigs = 3;
  }
}

message CommittedWrite {
  optional CommittedProof proof = 3;
}

message Dependency {
  required Write write = 1;
  optional Signatures write_sigs = 2;
  required int64 involved_group = 3;
}

message Write {
  optional bytes committed_value = 1;
  optional TimestampMessage committed_timestamp = 2;
  optional bytes prepared_value = 3;
  optional TimestampMessage prepared_timestamp = 4;
  optional bytes prepared_txn_digest = 5;
}

message ReadReply {
  required uint64 req_id = 1;
  required bytes key = 2;
  optional CommittedProof proof = 3;
  oneof prepared_oneof {
    Write write = 4;
    SignedMessage signed_write = 5;
  }
}

// Phase 1
message Transaction {
  required uint64 client_id = 1;
  required uint64 client_seq_num = 2;
  repeated int64 involved_groups = 3;
  repeated ReadMessage read_set = 4;
  repeated WriteMessage write_set = 5;
  repeated Dependency deps = 6;
  required TimestampMessage timestamp = 7;
}

message Phase1 {
  required uint64 req_id = 1;
  required Transaction txn = 2;
}


// fallback Phase1
message Phase1FB {
  required uint64 req_id =1;
  required Transaction txn = txn =2;
}

//fallback Phase1 reply
message Phase1FBReply {
  required uint64 req_id = 1;
  optional Phase1Reply p1r;
  optional Phase2Reply p2r;
  optional Writeback wb;
}

//fallback Phase2
message Phase2FB {
  required uint64 req_id = 1;
  required CommitDecision decision = 2;
  optional Transaction txn = 3;
  optional bytes txn_digest = 4;
  optional GroupedSignatures grouped_sigs = 5;
}
//fallback phase2R: Can be the same Phase2R as normal.

//fallback Invoke; info from p2fb is sort of redundant
message InvokeFB {
  required uint64 req_id = 1
  optional bytes txn_digest = 2;
  optional Phase2FB p2fb = 2;
}


// all to all move to new views; upon reception of a InvokeFB request and timeout on FB result message reception, this message is sent to all replicas, and forwarded if f+1 are received. Only forward once per view.
// Just assume for simplicty that only honest clients start invocations and therefore this message is never necessary. (Its fine if we always send it, but it might be unecessary and requires us to implement MACs too; or pay heavy signature price.)
message MoveView {
  required uint64 req_id = 1
  required bytes txn_digest = 2;
  required uint64 view = 3;
}


#fallback elect. Send this message to replica at view = v upon reception of InvokeFB or f+1 MoveView requests.
message ElectFB {
  required uint64 req_id = 1
  required bytes txn_digest = 2;
  required CommitDecision dec = 3;
  required uint64 view = 4; //dont need this for decision, just for round robin iteration mapping.
}

message DecisionFB {
  required uint64 req_id = 1
  required bytes txn_digest = 2;
  required CommitDecision dec = 3;
  required uint64 view = 4;
  repeated SignedMessage elect_sigs // want to send the Quorum of ElectFB messages. not sure if this is the correct way
}

message ConcurrencyControl {
  enum Result {
    COMMIT = 0;
    ABORT = 1;
    ABSTAIN = 2;
    WAIT = 3;
    RETRY = 4;
  }
  required Result ccr = 2;
  optional CommittedProof committed_conflict = 3;
  optional bytes txn_digest = 4;
}

message Phase1Reply {
  required uint64 req_id = 1;
  oneof concurrency_oneof {
    ConcurrencyControl cc = 2;
    SignedMessage signed_cc = 3;
  }
}

message Phase1Replies {
  repeated Phase1Reply replies = 1;
}


message Phase2 {
  required uint64 req_id = 1;
  required CommitDecision decision = 2;
  optional Transaction txn = 3;
  optional bytes txn_digest = 4;
  optional GroupedSignatures grouped_sigs = 5;
}

//ADD MATCHING VIEW, make it required?
message Phase2Decision {
  required CommitDecision decision = 2;
  optional bytes txn_digest = 3;
  optional uint64 view = 4;
}

message Phase2Reply {
  required uint64 req_id = 1;
  oneof p2_decision_oneof {
    Phase2Decision p2_decision = 2;
    SignedMessage signed_p2_decision = 3;
  }
}

message Writeback {
  required CommitDecision decision = 1;
  optional bytes txn_digest = 2;
  optional Transaction txn = 3;
  oneof reply_oneof {
    GroupedSignatures p1_sigs = 4; // fast path commit
    GroupedSignatures p2_sigs = 5; // slow path commit or abort
    CommittedProof conflict = 6;   // fast path abort
  }
}

message AbortInternal {
  required TimestampMessage ts = 1;
  repeated bytes read_set = 2;
}

message Abort {
  oneof internal_oneof {
    AbortInternal internal = 1;
    SignedMessage signed_internal = 2;
  }
}
