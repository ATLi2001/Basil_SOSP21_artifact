syntax = "proto2";

import "store/common/common-proto.proto";

package indicusstore.proto;

enum CommitDecision {
  COMMIT = 0;
  ABORT = 1;
}

message PackedMessage {
  required bytes msg = 1;
  required string type = 2;
}

message SignedMessage {
  required bytes packed_msg = 1;
  required uint64 process_id = 2;
  required bytes signature = 3;
}

message SignedMessages {
  repeated SignedMessage msgs = 1;
}

message Read {
  required uint64 req_id = 1;
  required bytes key = 2;
  required TimestampMessage timestamp = 3;
}

message GroupedPhase1Replies {
  map<uint64, Phase1Replies> replies = 1;
}

message GroupedSignedPhase1Replies {
  map<uint64, SignedMessages> replies = 1;
}

message CommittedProof {
  required Transaction txn = 1;
  oneof replies_oneof {
    GroupedPhase1Replies p1_replies = 2;
    GroupedSignedPhase1Replies signed_p1_replies = 3;
    Phase2Replies p2_replies = 4;
    SignedMessages signed_p2_replies = 5;
  }
}

message CommittedWrite {
  required bytes value = 1;
  required TimestampMessage timestamp = 2;
  optional CommittedProof proof = 3;
}

message Dependency {
  required PreparedWrite prepared = 1;
  optional PreparedProof proof = 2;
  required int64 involved_group = 3;
}

message PreparedWrite {
  required bytes value = 1;
  required TimestampMessage timestamp = 2;
  required bytes txn_digest = 3;
}

message PreparedWrites {
  repeated PreparedWrite writes = 1;
}

message PreparedProof {
  oneof prepared_oneof {
    PreparedWrites prepared = 1;
    SignedMessages signed_prepared = 2;
  }
}

message ReadReply {
  required uint64 req_id = 1;
  required bytes key = 2;
  optional CommittedWrite committed = 3;
  oneof prepared_oneof {
    PreparedWrite prepared = 4;
    SignedMessage signed_prepared = 5;
  }
}

// Phase 1
message Transaction {
  required uint64 client_id = 1;
  required uint64 client_seq_num = 2;
  repeated int64 involved_groups = 3;
  repeated ReadMessage read_set = 4;
  repeated WriteMessage write_set = 5;
  repeated Dependency deps = 6;
  required TimestampMessage timestamp = 7;
}

message Phase1 {
  required uint64 req_id = 1;
  required Transaction txn = 2;
}

message Phase1Reply {
  enum ConcurrencyControlResult {
    COMMIT = 0;
    ABORT = 1;
    ABSTAIN = 2;
    WAIT = 3;
    RETRY = 4;
  }
  required uint64 req_id = 1;
  required ConcurrencyControlResult ccr = 2;
  optional CommittedProof committed_conflict = 3;
  optional bytes txn_digest = 4;
}

message Phase1Replies {
  repeated Phase1Reply replies = 1;
}

message Phase2 {
  required uint64 req_id = 1;
  optional Transaction txn = 2;
  oneof p1_replies_oneof {
    GroupedPhase1Replies p1_replies = 3;
    GroupedSignedPhase1Replies signed_p1_replies = 4;
  }
  optional CommitDecision decision = 5;
}

message Phase2Reply {
  required uint64 req_id = 1;
  required CommitDecision decision = 2;
  optional bytes txn_digest = 3;
}

message Phase2Replies {
  repeated Phase2Reply replies = 1;
}

message Writeback {
  required uint64 req_id = 1;
  optional bytes txn_digest = 2;
  optional Transaction txn = 3;
  required CommitDecision decision = 4;
  optional CommittedProof proof = 5;
}

message Abort {
  required uint64 req_id = 1;
  required bytes txn_digest = 2;
}
